package main

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	yaml "gopkg.in/yaml.v3"
)

// Run with "go run ./scripts/finalize-swagger <input-file> <output-file>"
func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: finalize-swagger <input-file> <output-file>")
		os.Exit(1)
	}

	iFilename := os.Args[1]
	oFilename := os.Args[2]

	yamlNode, err := ReadInputFileAsYaml(iFilename)
	if err != nil {
		fmt.Println("Error reading input file:", err)
		os.Exit(1)
	}

	if err := FinalizeYaml(yamlNode); err != nil {
		fmt.Println("Error finalizing swagger file:", err)
		os.Exit(1)
	}

	if err := WriteYamlToFile(oFilename, yamlNode); err != nil {
		fmt.Println("Error writing output file:", err)
		os.Exit(1)
	}

	fmt.Println("Swagger file finalized successfully")
}

// FinalizeYaml finalizes the YAML file into the expected format.
func FinalizeYaml(yamlNode *yaml.Node) error {
	if err := AddMissingEnumValues(yamlNode); err != nil {
		return err
	}
	if err := AddOneOfEntries(yamlNode); err != nil {
		return err
	}
	if err := FinalizeNullnessOption(yamlNode); err != nil {
		return err
	}
	//nolint:revive // readability
	if err := RemoveRequiredFields(yamlNode); err != nil {
		return err
	}
	return nil
}

// AddMissingEnumValues adds the missing enum values to the YAML file. For any given schema, if a property exists
// that is defined as an enum, we want to ensure that the enum data is also represented by a new attribute: "x-enum-varnames".
// This attribute is used by the OpenAPI generator to generate the correct Go code for the enum.
//
// Example input:
//
//	components:
//	  schemas:
//	    Foo:
//	      enum:
//	        - BAR
//	        - BAZ
//
// Example output:
//
//	components:
//	  schemas:
//	    Foo:
//	      enum:
//	        - BAR
//	        - BAZ
//	      x-enum-varnames:
//	        - FooBar
//	        - FooBaz
//
// Note that the names are generated by the newEnumName function, which is a combination of the schema name and the
// enum value.
func AddMissingEnumValues(yamlNode *yaml.Node) error {
	// We are only concerned with the components.schemas nodes
	schemasNode := GetYamlNode(yamlNode, "components.schemas")
	if schemasNode == nil {
		return errors.New("no components.schemas node found")
	}

	// For each schema, we need to add the missing enum values
	for schemaName, schemaNode := range GetYamlChildrenMap(schemasNode) {
		// Get the the enum property of the schema. If the schema does not have an enum property, we can skip this schema
		// altogether.
		enumNode := GetYamlNode(schemaNode, "enum")
		if enumNode == nil {
			continue
		}

		// Build the enum varnames node using the schema name and the enum node
		enumNodes := buildEnumVarnames(schemaName, enumNode)

		// Add the "x-enum-varnames" mapping to the schema (the key is added as a scalar node, the value is added as a sequence node)
		schemaNode.Content = append(schemaNode.Content, &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: "x-enum-varnames",
		})
		schemaNode.Content = append(schemaNode.Content, &yaml.Node{
			Kind:    yaml.SequenceNode,
			Content: enumNodes,
		})
	}

	return nil
}

func buildEnumVarnames(nodeName string, enumNode *yaml.Node) []*yaml.Node {
	// Get the raw string enum values from the enum node
	enumValues := make([]string, 0, len(enumNode.Content))
	for _, child := range enumNode.Content {
		enumValues = append(enumValues, child.Value)
	}

	// Use the enum node name as the prefix for the enum values (removing the "Enum" suffix if it exists)
	prefix := strings.TrimSuffix(nodeName, "Enum")

	// Create the enum nodes
	enumNodes := make([]*yaml.Node, 0, len(enumValues))
	for _, enumValue := range enumValues {
		// Create the enum name, using the prefix and the enum value
		name := newEnumName(prefix, enumValue)

		// Create the enum node, using the name
		enumNodes = append(enumNodes, &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: name,
		})
	}

	return enumNodes
}

func newEnumName(prefix string, enumValue string) string {
	// Convert known abbreviations to upper case
	suffix := abbreviationsToUpper(enumValue)

	// If the suffix contains a hyphen, append the suffix "Legacy"
	if strings.Contains(suffix, "-") {
		suffix += "Legacy"
	}
	// Convert the enum value to upper camel case
	suffix = upperCamelCase(suffix)

	// Return the prefix and suffix combined
	return fmt.Sprintf("%s%s", prefix, suffix)
}

var abbreviationReplacers = []struct {
	re      *regexp.Regexp
	replace string
}{
	{regexp.MustCompile(`(?i)arm`), "ARM"},
	{regexp.MustCompile(`(?i)amd`), "AMD"},
	{regexp.MustCompile(`(?i)ssd`), "SSD"},
	{regexp.MustCompile(`(?i)sxm`), "SXM"},
	{regexp.MustCompile(`(?i)pcie`), "PCIe"},
	{regexp.MustCompile(`(?i)nvme`), "NVMe"},
}

func abbreviationsToUpper(s string) string {
	// Convert known abbreviations to upper case
	for _, r := range abbreviationReplacers {
		s = r.re.ReplaceAllString(s, r.replace)
	}
	return s
}

// AddOneOfEntries adds the oneOf entries to the YAML file. For any given schema, if a property exists that is defined
// with a type of string and a format of uuid, or an array with items of type string and a format of uuid, we want to
// ensure that the property is converted to a oneOf entry. This allows us to use the OpenAPI generator to generate the
// correct Go code for the property if we request that the full property be fetched, rather than just its UUID.
//
// Example input (single value):
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bar:
//	          type: string
//	          format: uuid
//
// Example output:
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bar:
//	          oneOf:
//	            - type:
//	                - string
//	                format: uuid
//	            - $ref: "#/components/schemas/Bar"
//	          x-go-json-tag: "bar,omitempty"
//
// Example input (array):
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bars:
//	          type: array
//	          items:
//	            type: string
//	            format: uuid
//
// Example output:
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bars:
//	          oneOf:
//	            - type:
//	                - string
//	                format: uuid
//	            - $ref: "#/components/schemas/Bar"
//	          x-go-json-tag: "bar,omitempty"
//		    x-go-json-tag: "bars,omitempty"
func AddOneOfEntries(yamlNode *yaml.Node) error { //nolint:gocyclo // readability
	// We are only concerned with the components.schemas nodes
	schemasNode := GetYamlNode(yamlNode, "components.schemas")
	if schemasNode == nil {
		return errors.New("no components.schemas node found")
	}

	// For each schema, we need to check its children for oneOf entries
	for _, schemaNode := range GetYamlChildrenMap(schemasNode) {
		// Get the properties node of the schema. If the schema does not have a properties node, we can skip this schema
		// altogether.
		propertiesNode := GetYamlNode(schemaNode, "properties")
		if propertiesNode == nil {
			continue
		}

		// If the properties node is not a mapping node (e.g. it's a sequence node), we can skip this schema altogether.
		if propertiesNode.Kind != yaml.MappingNode {
			return nil
		}

		// For each property defined on this schema, we need to check if it is a string or array of strings with a format of uuid.
		for i := 0; i < len(propertiesNode.Content); i += 2 {
			key := propertiesNode.Content[i]
			val := propertiesNode.Content[i+1]

			// Special case: we don't want to convert these fields to a oneOf entry. These fields may be defined as
			// a string, but they don't have corresponding schema nodes, so we can't convert them to a oneOf entry.
			if key.Value == "id" ||
				key.Value == "ids" ||
				key.Value == "experience_id" ||
				key.Value == "tenant_ids" ||
				key.Value == "required_gpus" ||
				key.Value == "pipelines" ||
				key.Value == "services" ||
				key.Value == "experience_branch" {
				continue
			}

			// Get the defined type of the property so that we can determine if it is a string or array of strings. If
			// the type attribute is missing, we can skip this property.
			nodeType := GetYamlNode(val, "type")
			if nodeType == nil {
				continue
			}

			var oneOfNode *yaml.Node
			if nodeType.Value == "string" { //nolint:staticcheck // if statement is preferable
				// If the node is a string, convert it to a oneOf entry
				oneOfNode = convertStringToOneOf(key, val)
			} else if nodeType.Value == "array" {
				// If the node is an array, convert it to a oneOf entry
				oneOfNode = convertArrayToOneOf(key, val)
			}

			if oneOfNode != nil {
				propertiesNode.Content[i+1] = oneOfNode
			}
		}
	}
	return nil
}

// ConvertStringToOneOf converts a single value to a oneOf entry
//
// This is a single value, so we want to convert it from something like this:
//
//	foo:
//		type: string
//		format: uuid
//
// to something like this:
//
//	foo:
//		oneOf:
//			- type:
//				- string
//			  format: uuid
//			- $ref: "#/components/schemas/Foo"
//		x-go-json-tag: foo,omitempty
func convertStringToOneOf(key *yaml.Node, node *yaml.Node) *yaml.Node {
	nodeFormat := GetYamlNode(node, "format")
	if nodeFormat == nil {
		// If the node has no format, return early as we can't convert it to a oneOf entry
		return nil
	}
	if nodeFormat.Value != "uuid" {
		// If the node is not a string or uuid, return early as we can't convert it to a oneOf entry
		return nil
	}

	// Get the component name, which should be the singular form of the key value in upper camel case
	var componentName, fieldName string

	//nolint:gocritic // readability
	if strings.HasSuffix(key.Value, "ies") {
		componentName = strings.TrimSuffix(key.Value, "ies") + "y"
		componentName = upperCamelCase(componentName)
	} else if strings.HasSuffix(key.Value, "s") {
		componentName = strings.TrimSuffix(key.Value, "s")
		componentName = upperCamelCase(componentName)
	} else {
		componentName = upperCamelCase(key.Value)
	}

	// Get the field name, which should be the same as the component name, but lower camel case
	fieldName = strings.ToLower(componentName[0:1]) + componentName[1:]

	//nolint:dupl //ok
	return &yaml.Node{
		Kind: yaml.MappingNode,
		Content: []*yaml.Node{
			// oneOf:
			{Kind: yaml.ScalarNode, Value: "oneOf"},
			{
				Kind: yaml.SequenceNode,
				Content: []*yaml.Node{
					{
						Kind: yaml.MappingNode,
						Content: []*yaml.Node{
							// - type:
							{Kind: yaml.ScalarNode, Value: "type"},
							{
								Kind: yaml.SequenceNode,
								// - string
								Content: []*yaml.Node{{Kind: yaml.ScalarNode, Value: "string"}},
							},
							// - format: uuid
							{Kind: yaml.ScalarNode, Value: "format"},
							{Kind: yaml.ScalarNode, Value: "uuid"},
						},
					},
					{
						Kind: yaml.MappingNode,
						Content: []*yaml.Node{
							// - $ref: "#/components/schemas/<componentName>"
							{Kind: yaml.ScalarNode, Value: "$ref"},
							{Kind: yaml.ScalarNode, Value: fmt.Sprintf("#/components/schemas/%s", componentName), Style: yaml.DoubleQuotedStyle},
						},
					},
				},
			},
			// x-go-json-tag: "<fieldName>,omitempty"
			{Kind: yaml.ScalarNode, Value: "x-go-json-tag"},
			{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%s,omitempty", fieldName), Style: yaml.DoubleQuotedStyle},
		},
	}
}

// convertArrayToOneOf converts an array to a oneOf entry
//
// This is an array, so we want to convert it from something like this:
//
//	foos:
//		type: array
//		items:
//			type: string
//			format: uuid
//
// to something like this:
//
//	foos:
//		type: array
//		items:
//			oneOf:
//				- type:
//					- string
//				  format: uuid
//				- $ref: "#/components/schemas/Foo"
//			x-go-json-tag: "foos,omitempty"
//		x-go-json-tag: "foo,omitempty"
//
// Note that the x-go-json-tag is added to the original node, not the oneOf entry
func convertArrayToOneOf(key *yaml.Node, node *yaml.Node) *yaml.Node {
	nodeItemType := GetYamlNode(node, "items.type")
	if nodeItemType == nil {
		// If the node has no items.type, return early as we can't convert it to a oneOf entry
		return nil
	}

	nodeItemFormat := GetYamlNode(node, "items.format")
	if nodeItemFormat == nil {
		// If the node has no items.format, return early as we can't convert it to a oneOf entry
		return nil
	}

	if nodeItemType.Value != "string" || nodeItemFormat.Value != "uuid" {
		// If the node is not a string or uuid, return early as we can't convert it to a oneOf entry
		return nil
	}

	// Get the component name, which should be the singular form of the key value in upper camel case
	var componentName string

	//nolint:gocritic // readability
	if strings.HasSuffix(key.Value, "ies") {
		componentName = strings.TrimSuffix(key.Value, "ies") + "y"
		componentName = upperCamelCase(componentName)
	} else if strings.HasSuffix(key.Value, "s") {
		componentName = strings.TrimSuffix(key.Value, "s")
		componentName = upperCamelCase(componentName)
	} else {
		componentName = upperCamelCase(key.Value)
	}

	// Get the field name, which should be the same as the component name, but lower camel case
	fieldName := strings.ToLower(componentName[0:1]) + componentName[1:]

	// Get the fields name, which should be the same as the field name, but plural
	fieldsName := fieldName + "s"

	//nolint:dupl //ok
	return &yaml.Node{
		Kind: yaml.MappingNode,
		Content: []*yaml.Node{
			// type: array
			{Kind: yaml.ScalarNode, Value: "type"},
			{Kind: yaml.ScalarNode, Value: "array"},
			// items:
			{Kind: yaml.ScalarNode, Value: "items"},
			{
				Kind: yaml.MappingNode,
				Content: []*yaml.Node{
					// oneOf:
					{Kind: yaml.ScalarNode, Value: "oneOf"},
					{
						Kind: yaml.SequenceNode,
						Content: []*yaml.Node{
							{
								Kind: yaml.MappingNode,
								Content: []*yaml.Node{
									// - type:
									{Kind: yaml.ScalarNode, Value: "type"},
									{
										Kind: yaml.SequenceNode,
										// - string
										Content: []*yaml.Node{{Kind: yaml.ScalarNode, Value: "string"}},
									},
									// - format: uuid
									{Kind: yaml.ScalarNode, Value: "format"},
									{Kind: yaml.ScalarNode, Value: "uuid"},
								},
							},
							{
								Kind: yaml.MappingNode,
								Content: []*yaml.Node{
									// - $ref: "#/components/schemas/<componentName>"
									{Kind: yaml.ScalarNode, Value: "$ref"},
									{Kind: yaml.ScalarNode, Value: fmt.Sprintf("#/components/schemas/%s", componentName), Style: yaml.DoubleQuotedStyle},
								},
							},
						},
					},
					// x-go-json-tag: "<fieldName>,omitempty"
					{Kind: yaml.ScalarNode, Value: "x-go-json-tag"},
					{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%s,omitempty", fieldName), Style: yaml.DoubleQuotedStyle},
				},
			},
			// x-go-json-tag: "<fieldsName>,omitempty"
			{Kind: yaml.ScalarNode, Value: "x-go-json-tag"},
			{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%s,omitempty", fieldsName), Style: yaml.DoubleQuotedStyle},
		},
	}
}

// FinalizeNullnessOption alters "oneOf" property attributes where appropriate. If a "oneOf" property is found to be a sequence of options,
// with references to the "BlankEnum" or "NullEnum" schema, an alteration is made. "BlankEnum" is removed outright, and "NullEnum" is replaced
// with a simple reference to the "null" type.
//
// Example input:
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bar:
//	          oneOf:
//	            - $ref: "#/components/schemas/Bar"
//	            - $ref: "#/components/schemas/NullEnum"
//	            - $ref: "#/components/schemas/BlankEnum"
//
// Example output:
//
//	components:
//	  schemas:
//	    Foo:
//	      properties:
//	        bar:
//	          oneOf:
//	            - $ref: "#/components/schemas/Bar"
//	            - type: "null"
func FinalizeNullnessOption(yamlNode *yaml.Node) error {
	// We are only concerned with the components.schemas nodes
	schemasNode := GetYamlNode(yamlNode, "components.schemas")
	if schemasNode == nil {
		return errors.New("no components.schemas node found")
	}

	// For each schema, we need to check its children for blank enum values
	for _, schemaNode := range GetYamlChildrenMap(schemasNode) {
		// Get the properties node of the schema. If the schema does not have a properties node, we can skip this schema
		// altogether.
		propertiesNode := GetYamlNode(schemaNode, "properties")
		if propertiesNode == nil {
			continue
		}

		// If the properties node is not a mapping node (e.g. it's a sequence node), we can skip this schema altogether.
		if propertiesNode.Kind != yaml.MappingNode {
			return nil
		}

		// For each property, we need to check its children for blank enum values
		for i := 0; i < len(propertiesNode.Content); i += 2 {
			propertyVal := propertiesNode.Content[i+1]

			// If the property is not a mapping node, skip it
			if propertyVal.Kind != yaml.MappingNode {
				continue
			}

			// For each attribute, we need to check if it is the oneOf attribute
			for i := 0; i < len(propertyVal.Content); i += 2 {
				attributeKey := propertyVal.Content[i]
				attributeVal := propertyVal.Content[i+1]

				// If the attribute is not the oneOf attribute, skip it
				if attributeKey.Value != "oneOf" {
					continue
				}

				// Remove the blank enum values from the oneOf attribute
				oneOfNodeEntries := removeBlankEnumValuesFromOneOf(attributeVal)
				if oneOfNodeEntries != nil {
					// Replace the oneOf attribute with the new oneOf attribute
					propertyVal.Content[i+1] = &yaml.Node{
						Kind:    yaml.SequenceNode,
						Content: oneOfNodeEntries,
					}
				}
				// We only want to remove the blank enum values from the oneOf attribute, so we can break out of the loop
				break
			}
		}
	}

	return nil
}

func removeBlankEnumValuesFromOneOf(oneOfSequenceNode *yaml.Node) []*yaml.Node {
	if oneOfSequenceNode.Kind != yaml.SequenceNode {
		return nil
	}

	oneOfNodes := make([]*yaml.Node, 0, len(oneOfSequenceNode.Content))

	for _, oneOfNode := range oneOfSequenceNode.Content {
		if oneOfNode.Kind != yaml.MappingNode {
			// We want to keep the non-mapping nodes in the oneOf sequence
			oneOfNodes = append(oneOfNodes, oneOfNode)
			continue
		}

		if len(oneOfNode.Content) != 2 {
			// This is a mapping node, but it's not the expected "$ref: <value>" format
			oneOfNodes = append(oneOfNodes, oneOfNode)
			continue
		}

		key := oneOfNode.Content[0]
		val := oneOfNode.Content[1]

		if key.Value == "$ref" && val.Value == "#/components/schemas/BlankEnum" { //nolint:gocritic // readability
			// This is a blank enum value, so we want to remove it
			continue
		} else if key.Value == "$ref" && val.Value == "#/components/schemas/NullEnum" {
			// This is a null enum value, so we want to replace it with the string "null"
			key.Value = "type"
			val.Value = "null"
			oneOfNodes = append(oneOfNodes, oneOfNode)
		} else {
			// This is a valid oneOf entry, so we want to keep it
			oneOfNodes = append(oneOfNodes, oneOfNode)
		}
	}

	return oneOfNodes
}

// requiredFieldsToRemove maps component names to lists of required fields that should be removed
var requiredFieldsToRemove = map[string][]string{
	"Gpu":        {"node_count"},
	"Cluster":    {"gpu_alias", "gpu_count", "node_count"},
	"Deployment": {"experience"},
	// Add more component mappings as needed, e.g.:
	// "OtherComponent": {"field1", "field2"},
}

func RemoveRequiredFields(yamlNode *yaml.Node) error {
	schemasNode := GetYamlNode(yamlNode, "components.schemas")
	if schemasNode == nil {
		return errors.New("no components.schemas node found")
	}

	// Iterate over all components that need required fields removed
	for componentName, fieldsToRemove := range requiredFieldsToRemove {
		// Get the component schema
		componentNode := GetYamlNode(schemasNode, componentName)
		if componentNode == nil {
			// If the component doesn't exist, skip it
			continue
		}

		// Get the required field from the component schema
		requiredNode := GetYamlNode(componentNode, "required")
		if requiredNode == nil {
			// If there's no required field, nothing to remove for this component
			continue
		}

		// The required field should be a sequence node
		if requiredNode.Kind != yaml.SequenceNode {
			continue
		}

		// Filter out the specified fields from the required array
		filteredContent := make([]*yaml.Node, 0, len(requiredNode.Content))
		for _, node := range requiredNode.Content {
			shouldRemove := false
			for _, fieldToRemove := range fieldsToRemove {
				if node.Value == fieldToRemove {
					shouldRemove = true
					break
				}
			}
			if !shouldRemove {
				filteredContent = append(filteredContent, node)
			}
		}

		// Update the required node's content
		requiredNode.Content = filteredContent
	}

	return nil
}

func upperCamelCase(s string) string {
	// Remove all characters that are not alphanumeric or spaces or underscores or hyphens
	s = regexp.MustCompile("[^a-zA-Z0-9_ -]+").ReplaceAllString(s, "")

	// Replace all underscores and hyphens with spaces
	s = strings.ReplaceAll(s, "_", " ")
	s = strings.ReplaceAll(s, "-", " ")

	// Title case s
	s = cases.Title(language.AmericanEnglish, cases.NoLower).String(s)

	// Remove all spaces
	s = strings.ReplaceAll(s, " ", "")

	return s
}
