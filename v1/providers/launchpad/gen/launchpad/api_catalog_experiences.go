/*
NVIDIA LaunchPad API

RESTful API for interacting with the NVIDIA LaunchPad platform

API version: 2.36.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// CatalogExperiencesAPIService CatalogExperiencesAPI service
type CatalogExperiencesAPIService service

type ApiCatalogExperiencesBulkCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	csvFile    *os.File
}

func (r ApiCatalogExperiencesBulkCreateRequest) CsvFile(csvFile *os.File) ApiCatalogExperiencesBulkCreateRequest {
	r.csvFile = csvFile
	return r
}

func (r ApiCatalogExperiencesBulkCreateRequest) Execute() (*ExperienceBulk, *http.Response, error) {
	return r.ApiService.CatalogExperiencesBulkCreateExecute(r)
}

/*
CatalogExperiencesBulkCreate Method for CatalogExperiencesBulkCreate

Create experiences in bulk via CSV file upload

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogExperiencesBulkCreateRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesBulkCreate(ctx context.Context) ApiCatalogExperiencesBulkCreateRequest {
	return ApiCatalogExperiencesBulkCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExperienceBulk
func (a *CatalogExperiencesAPIService) CatalogExperiencesBulkCreateExecute(r ApiCatalogExperiencesBulkCreateRequest) (*ExperienceBulk, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceBulk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesBulkCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.csvFile == nil {
		return localVarReturnValue, nil, reportError("csvFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var csvFileLocalVarFormFileName string
	var csvFileLocalVarFileName string
	var csvFileLocalVarFileBytes []byte

	csvFileLocalVarFormFileName = "csv_file"
	csvFileLocalVarFile := r.csvFile

	if csvFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(csvFileLocalVarFile)

		csvFileLocalVarFileBytes = fbs
		csvFileLocalVarFileName = csvFileLocalVarFile.Name()
		csvFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: csvFileLocalVarFileBytes, fileName: csvFileLocalVarFileName, formFileName: csvFileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesBulkPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *CatalogExperiencesAPIService
	experienceBulkUpdate *ExperienceBulkUpdate
}

func (r ApiCatalogExperiencesBulkPartialUpdateRequest) ExperienceBulkUpdate(experienceBulkUpdate ExperienceBulkUpdate) ApiCatalogExperiencesBulkPartialUpdateRequest {
	r.experienceBulkUpdate = &experienceBulkUpdate
	return r
}

func (r ApiCatalogExperiencesBulkPartialUpdateRequest) Execute() (*ExperienceBulkUpdate, *http.Response, error) {
	return r.ApiService.CatalogExperiencesBulkPartialUpdateExecute(r)
}

/*
CatalogExperiencesBulkPartialUpdate Method for CatalogExperiencesBulkPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogExperiencesBulkPartialUpdateRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesBulkPartialUpdate(ctx context.Context) ApiCatalogExperiencesBulkPartialUpdateRequest {
	return ApiCatalogExperiencesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExperienceBulkUpdate
func (a *CatalogExperiencesAPIService) CatalogExperiencesBulkPartialUpdateExecute(r ApiCatalogExperiencesBulkPartialUpdateRequest) (*ExperienceBulkUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceBulkUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceBulkUpdate == nil {
		return localVarReturnValue, nil, reportError("experienceBulkUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceBulkUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	experience *Experience
}

func (r ApiCatalogExperiencesCreateRequest) Experience(experience Experience) ApiCatalogExperiencesCreateRequest {
	r.experience = &experience
	return r
}

func (r ApiCatalogExperiencesCreateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.CatalogExperiencesCreateExecute(r)
}

/*
CatalogExperiencesCreate Method for CatalogExperiencesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogExperiencesCreateRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesCreate(ctx context.Context) ApiCatalogExperiencesCreateRequest {
	return ApiCatalogExperiencesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) CatalogExperiencesCreateExecute(r ApiCatalogExperiencesCreateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesDestroyRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
}

func (r ApiCatalogExperiencesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogExperiencesDestroyExecute(r)
}

/*
CatalogExperiencesDestroy Method for CatalogExperiencesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiCatalogExperiencesDestroyRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesDestroy(ctx context.Context, id string) ApiCatalogExperiencesDestroyRequest {
	return ApiCatalogExperiencesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CatalogExperiencesAPIService) CatalogExperiencesDestroyExecute(r ApiCatalogExperiencesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogExperiencesHistoryListRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	page       *int32
	pageSize   *int32
}

// A page number within the paginated result set.
func (r ApiCatalogExperiencesHistoryListRequest) Page(page int32) ApiCatalogExperiencesHistoryListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogExperiencesHistoryListRequest) PageSize(pageSize int32) ApiCatalogExperiencesHistoryListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCatalogExperiencesHistoryListRequest) Execute() (*PaginatedModelChangeList, *http.Response, error) {
	return r.ApiService.CatalogExperiencesHistoryListExecute(r)
}

/*
CatalogExperiencesHistoryList Method for CatalogExperiencesHistoryList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCatalogExperiencesHistoryListRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesHistoryList(ctx context.Context, id string) ApiCatalogExperiencesHistoryListRequest {
	return ApiCatalogExperiencesHistoryListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PaginatedModelChangeList
func (a *CatalogExperiencesAPIService) CatalogExperiencesHistoryListExecute(r ApiCatalogExperiencesHistoryListRequest) (*PaginatedModelChangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedModelChangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesListRequest struct {
	ctx              context.Context
	ApiService       *CatalogExperiencesAPIService
	assignee         *string
	autoapprove      *bool
	autoprovision    *bool
	bootstrap        *bool
	catalogId        *string
	catalogIdAlias   *string
	category         *[]string
	collectionBranch *string
	expand           *string
	experience       *string
	experienceBranch *string
	fields           *string
	garageId         *string
	gcBranch         *string
	gpuCount         *int32
	gpuOsName        *string
	gpuOsRelease     *string
	gpuOsVersion     *string
	id               *string
	nodeCount        *int32
	omit             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	persona          *string
	pipeline         *int32
	platform         *string
	provider         *string
	published        *[]string
	requiresGpu      *string
	saLab            *bool
	search           *string
	systemArch       *string
	vgpuProfile      *string
}

func (r ApiCatalogExperiencesListRequest) Assignee(assignee string) ApiCatalogExperiencesListRequest {
	r.assignee = &assignee
	return r
}

func (r ApiCatalogExperiencesListRequest) Autoapprove(autoapprove bool) ApiCatalogExperiencesListRequest {
	r.autoapprove = &autoapprove
	return r
}

func (r ApiCatalogExperiencesListRequest) Autoprovision(autoprovision bool) ApiCatalogExperiencesListRequest {
	r.autoprovision = &autoprovision
	return r
}

func (r ApiCatalogExperiencesListRequest) Bootstrap(bootstrap bool) ApiCatalogExperiencesListRequest {
	r.bootstrap = &bootstrap
	return r
}

func (r ApiCatalogExperiencesListRequest) CatalogId(catalogId string) ApiCatalogExperiencesListRequest {
	r.catalogId = &catalogId
	return r
}

func (r ApiCatalogExperiencesListRequest) CatalogIdAlias(catalogIdAlias string) ApiCatalogExperiencesListRequest {
	r.catalogIdAlias = &catalogIdAlias
	return r
}

// Multiple values may be separated by commas.  * &#x60;AI&#x60; - AI * &#x60;Clara&#x60; - Clara * &#x60;Data Science&#x60; - Data Science * &#x60;3D Design Collaboration and Simulation&#x60; - 3D Design Collaboration and Simulation * &#x60;Developer&#x60; - Developer * &#x60;Infrastructure Optimization&#x60; - Infrastructure Optimization
func (r ApiCatalogExperiencesListRequest) Category(category []string) ApiCatalogExperiencesListRequest {
	r.category = &category
	return r
}

func (r ApiCatalogExperiencesListRequest) CollectionBranch(collectionBranch string) ApiCatalogExperiencesListRequest {
	r.collectionBranch = &collectionBranch
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;required_gpus\&quot;).
func (r ApiCatalogExperiencesListRequest) Expand(expand string) ApiCatalogExperiencesListRequest {
	r.expand = &expand
	return r
}

func (r ApiCatalogExperiencesListRequest) Experience(experience string) ApiCatalogExperiencesListRequest {
	r.experience = &experience
	return r
}

func (r ApiCatalogExperiencesListRequest) ExperienceBranch(experienceBranch string) ApiCatalogExperiencesListRequest {
	r.experienceBranch = &experienceBranch
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogExperiencesListRequest) Fields(fields string) ApiCatalogExperiencesListRequest {
	r.fields = &fields
	return r
}

func (r ApiCatalogExperiencesListRequest) GarageId(garageId string) ApiCatalogExperiencesListRequest {
	r.garageId = &garageId
	return r
}

func (r ApiCatalogExperiencesListRequest) GcBranch(gcBranch string) ApiCatalogExperiencesListRequest {
	r.gcBranch = &gcBranch
	return r
}

func (r ApiCatalogExperiencesListRequest) GpuCount(gpuCount int32) ApiCatalogExperiencesListRequest {
	r.gpuCount = &gpuCount
	return r
}

func (r ApiCatalogExperiencesListRequest) GpuOsName(gpuOsName string) ApiCatalogExperiencesListRequest {
	r.gpuOsName = &gpuOsName
	return r
}

func (r ApiCatalogExperiencesListRequest) GpuOsRelease(gpuOsRelease string) ApiCatalogExperiencesListRequest {
	r.gpuOsRelease = &gpuOsRelease
	return r
}

func (r ApiCatalogExperiencesListRequest) GpuOsVersion(gpuOsVersion string) ApiCatalogExperiencesListRequest {
	r.gpuOsVersion = &gpuOsVersion
	return r
}

func (r ApiCatalogExperiencesListRequest) Id(id string) ApiCatalogExperiencesListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogExperiencesListRequest) NodeCount(nodeCount int32) ApiCatalogExperiencesListRequest {
	r.nodeCount = &nodeCount
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogExperiencesListRequest) Omit(omit string) ApiCatalogExperiencesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogExperiencesListRequest) Ordering(ordering string) ApiCatalogExperiencesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogExperiencesListRequest) Page(page int32) ApiCatalogExperiencesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogExperiencesListRequest) PageSize(pageSize int32) ApiCatalogExperiencesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCatalogExperiencesListRequest) Persona(persona string) ApiCatalogExperiencesListRequest {
	r.persona = &persona
	return r
}

func (r ApiCatalogExperiencesListRequest) Pipeline(pipeline int32) ApiCatalogExperiencesListRequest {
	r.pipeline = &pipeline
	return r
}

// Base platform that the experience will be provisioned onto  * &#x60;air&#x60; - NVIDIA Air * &#x60;flight_deck&#x60; - Flight Deck * &#x60;kvm_bastion&#x60; - KVM Bastion * &#x60;lp-vmware-platform&#x60; - lp-vmware-platform * &#x60;minimal&#x60; - minimal * &#x60;openshift&#x60; - OpenShift * &#x60;vsphere&#x60; - vSphere * &#x60;vsphere_horizon&#x60; - VMware Horizon * &#x60;vsphere7&#x60; - vSphere 7 * &#x60;vsphere8&#x60; - vSphere 8
func (r ApiCatalogExperiencesListRequest) Platform(platform string) ApiCatalogExperiencesListRequest {
	r.platform = &platform
	return r
}

func (r ApiCatalogExperiencesListRequest) Provider(provider string) ApiCatalogExperiencesListRequest {
	r.provider = &provider
	return r
}

// Multiple values may be separated by commas.  * &#x60;draft&#x60; - draft * &#x60;no&#x60; - no * &#x60;yes&#x60; - yes
func (r ApiCatalogExperiencesListRequest) Published(published []string) ApiCatalogExperiencesListRequest {
	r.published = &published
	return r
}

// Only include experiences that require a given GPU ID or model
func (r ApiCatalogExperiencesListRequest) RequiresGpu(requiresGpu string) ApiCatalogExperiencesListRequest {
	r.requiresGpu = &requiresGpu
	return r
}

func (r ApiCatalogExperiencesListRequest) SaLab(saLab bool) ApiCatalogExperiencesListRequest {
	r.saLab = &saLab
	return r
}

// Search for experiences by assignee, catalog_id, catalog_id_alias, category, collection_branch, description, experience, experience_branch, gc_branch, gpu_os_name, gpu_os_release, gpu_os_version, id, persona, pipeline, platform, provider name, required_gpus model, system_arch, title, vgpu_profile
func (r ApiCatalogExperiencesListRequest) Search(search string) ApiCatalogExperiencesListRequest {
	r.search = &search
	return r
}

// Required CPU architecture  * &#x60;amd64&#x60; - amd64 * &#x60;arm64&#x60; - arm64
func (r ApiCatalogExperiencesListRequest) SystemArch(systemArch string) ApiCatalogExperiencesListRequest {
	r.systemArch = &systemArch
	return r
}

// vGPU profile name used by the experience  * &#x60;air&#x60; - NVIDIA Air * &#x60;bright_cluster&#x60; - Bright Cluster * &#x60;bright-cluster&#x60; - Bright Cluster (legacy option) * &#x60;flight_deck&#x60; - Flight Deck * &#x60;flight-deck&#x60; - Flight Deck (legacy option) * &#x60;nvidia_a40-48q&#x60; - nvidia_a40-48q * &#x60;nvidia-ai-enterprise&#x60; - NVIDIA AI Enterprise * &#x60;nvidia_l40s-48q&#x60; - nvidia_l40s-48q * &#x60;nvidia_rtx_pro_6000_blackwell_dc-4-96q&#x60; - nvidia_rtx_pro_6000_blackwell_dc-4-96q * &#x60;nvidia_rtx_pro_6000_blackwell_dc-96q&#x60; - nvidia_rtx_pro_6000_blackwell_dc-96q * &#x60;openshift&#x60; - OpenShift * &#x60;platform_only&#x60; - platform_only * &#x60;vmware_itadmin&#x60; - VMware IT admin
func (r ApiCatalogExperiencesListRequest) VgpuProfile(vgpuProfile string) ApiCatalogExperiencesListRequest {
	r.vgpuProfile = &vgpuProfile
	return r
}

func (r ApiCatalogExperiencesListRequest) Execute() (*PaginatedExperienceList, *http.Response, error) {
	return r.ApiService.CatalogExperiencesListExecute(r)
}

/*
CatalogExperiencesList Method for CatalogExperiencesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogExperiencesListRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesList(ctx context.Context) ApiCatalogExperiencesListRequest {
	return ApiCatalogExperiencesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedExperienceList
func (a *CatalogExperiencesAPIService) CatalogExperiencesListExecute(r ApiCatalogExperiencesListRequest) (*PaginatedExperienceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedExperienceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "form", "")
	}
	if r.autoapprove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoapprove", r.autoapprove, "form", "")
	}
	if r.autoprovision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoprovision", r.autoprovision, "form", "")
	}
	if r.bootstrap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bootstrap", r.bootstrap, "form", "")
	}
	if r.catalogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalog_id", r.catalogId, "form", "")
	}
	if r.catalogIdAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalog_id_alias", r.catalogIdAlias, "form", "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "csv")
	}
	if r.collectionBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection_branch", r.collectionBranch, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.experienceBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience_branch", r.experienceBranch, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.garageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "garage_id", r.garageId, "form", "")
	}
	if r.gcBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gc_branch", r.gcBranch, "form", "")
	}
	if r.gpuCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_count", r.gpuCount, "form", "")
	}
	if r.gpuOsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_name", r.gpuOsName, "form", "")
	}
	if r.gpuOsRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_release", r.gpuOsRelease, "form", "")
	}
	if r.gpuOsVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_version", r.gpuOsVersion, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.nodeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_count", r.nodeCount, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.persona != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persona", r.persona, "form", "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "form", "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	}
	if r.published != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "published", r.published, "form", "csv")
	}
	if r.requiresGpu != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requires_gpu", r.requiresGpu, "form", "")
	}
	if r.saLab != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lab", r.saLab, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.systemArch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "system_arch", r.systemArch, "form", "")
	}
	if r.vgpuProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vgpu_profile", r.vgpuProfile, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesPartialUpdateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	experience *Experience
}

func (r ApiCatalogExperiencesPartialUpdateRequest) Experience(experience Experience) ApiCatalogExperiencesPartialUpdateRequest {
	r.experience = &experience
	return r
}

func (r ApiCatalogExperiencesPartialUpdateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.CatalogExperiencesPartialUpdateExecute(r)
}

/*
CatalogExperiencesPartialUpdate Method for CatalogExperiencesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiCatalogExperiencesPartialUpdateRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesPartialUpdate(ctx context.Context, id string) ApiCatalogExperiencesPartialUpdateRequest {
	return ApiCatalogExperiencesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) CatalogExperiencesPartialUpdateExecute(r ApiCatalogExperiencesPartialUpdateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	expand     *string
	fields     *string
	omit       *string
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;required_gpus\&quot;).
func (r ApiCatalogExperiencesRetrieveRequest) Expand(expand string) ApiCatalogExperiencesRetrieveRequest {
	r.expand = &expand
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogExperiencesRetrieveRequest) Fields(fields string) ApiCatalogExperiencesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogExperiencesRetrieveRequest) Omit(omit string) ApiCatalogExperiencesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiCatalogExperiencesRetrieveRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.CatalogExperiencesRetrieveExecute(r)
}

/*
CatalogExperiencesRetrieve Method for CatalogExperiencesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiCatalogExperiencesRetrieveRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesRetrieve(ctx context.Context, id string) ApiCatalogExperiencesRetrieveRequest {
	return ApiCatalogExperiencesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) CatalogExperiencesRetrieveExecute(r ApiCatalogExperiencesRetrieveRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesStatsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
}

func (r ApiCatalogExperiencesStatsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogExperiencesStatsRetrieveExecute(r)
}

/*
CatalogExperiencesStatsRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogExperiencesStatsRetrieveRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesStatsRetrieve(ctx context.Context) ApiCatalogExperiencesStatsRetrieveRequest {
	return ApiCatalogExperiencesStatsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CatalogExperiencesAPIService) CatalogExperiencesStatsRetrieveExecute(r ApiCatalogExperiencesStatsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesStatsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogExperiencesUpdateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	experience *Experience
}

func (r ApiCatalogExperiencesUpdateRequest) Experience(experience Experience) ApiCatalogExperiencesUpdateRequest {
	r.experience = &experience
	return r
}

func (r ApiCatalogExperiencesUpdateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.CatalogExperiencesUpdateExecute(r)
}

/*
CatalogExperiencesUpdate Method for CatalogExperiencesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiCatalogExperiencesUpdateRequest
*/
func (a *CatalogExperiencesAPIService) CatalogExperiencesUpdate(ctx context.Context, id string) ApiCatalogExperiencesUpdateRequest {
	return ApiCatalogExperiencesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) CatalogExperiencesUpdateExecute(r ApiCatalogExperiencesUpdateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.CatalogExperiencesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
