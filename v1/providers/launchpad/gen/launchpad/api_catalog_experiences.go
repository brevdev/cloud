/*
NVIDIA LaunchPad API

RESTful API for interacting with the NVIDIA LaunchPad platform

API version: 2.39.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// CatalogExperiencesAPIService CatalogExperiencesAPI service
type CatalogExperiencesAPIService service

type ApiV1CatalogExperiencesBulkCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	csvFile    *os.File
}

func (r ApiV1CatalogExperiencesBulkCreateRequest) CsvFile(csvFile *os.File) ApiV1CatalogExperiencesBulkCreateRequest {
	r.csvFile = csvFile
	return r
}

func (r ApiV1CatalogExperiencesBulkCreateRequest) Execute() (*ExperienceBulk, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesBulkCreateExecute(r)
}

/*
V1CatalogExperiencesBulkCreate Method for V1CatalogExperiencesBulkCreate

Create experiences in bulk via CSV file upload

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogExperiencesBulkCreateRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesBulkCreate(ctx context.Context) ApiV1CatalogExperiencesBulkCreateRequest {
	return ApiV1CatalogExperiencesBulkCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExperienceBulk
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesBulkCreateExecute(r ApiV1CatalogExperiencesBulkCreateRequest) (*ExperienceBulk, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceBulk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesBulkCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.csvFile == nil {
		return localVarReturnValue, nil, reportError("csvFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var csvFileLocalVarFormFileName string
	var csvFileLocalVarFileName string
	var csvFileLocalVarFileBytes []byte

	csvFileLocalVarFormFileName = "csv_file"
	csvFileLocalVarFile := r.csvFile

	if csvFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(csvFileLocalVarFile)

		csvFileLocalVarFileBytes = fbs
		csvFileLocalVarFileName = csvFileLocalVarFile.Name()
		csvFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: csvFileLocalVarFileBytes, fileName: csvFileLocalVarFileName, formFileName: csvFileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesBulkPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *CatalogExperiencesAPIService
	experienceBulkUpdate *ExperienceBulkUpdate
}

func (r ApiV1CatalogExperiencesBulkPartialUpdateRequest) ExperienceBulkUpdate(experienceBulkUpdate ExperienceBulkUpdate) ApiV1CatalogExperiencesBulkPartialUpdateRequest {
	r.experienceBulkUpdate = &experienceBulkUpdate
	return r
}

func (r ApiV1CatalogExperiencesBulkPartialUpdateRequest) Execute() (*ExperienceBulkUpdate, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesBulkPartialUpdateExecute(r)
}

/*
V1CatalogExperiencesBulkPartialUpdate Method for V1CatalogExperiencesBulkPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogExperiencesBulkPartialUpdateRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesBulkPartialUpdate(ctx context.Context) ApiV1CatalogExperiencesBulkPartialUpdateRequest {
	return ApiV1CatalogExperiencesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExperienceBulkUpdate
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesBulkPartialUpdateExecute(r ApiV1CatalogExperiencesBulkPartialUpdateRequest) (*ExperienceBulkUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceBulkUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceBulkUpdate == nil {
		return localVarReturnValue, nil, reportError("experienceBulkUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceBulkUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	experience *Experience
}

func (r ApiV1CatalogExperiencesCreateRequest) Experience(experience Experience) ApiV1CatalogExperiencesCreateRequest {
	r.experience = &experience
	return r
}

func (r ApiV1CatalogExperiencesCreateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesCreateExecute(r)
}

/*
V1CatalogExperiencesCreate Method for V1CatalogExperiencesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogExperiencesCreateRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesCreate(ctx context.Context) ApiV1CatalogExperiencesCreateRequest {
	return ApiV1CatalogExperiencesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesCreateExecute(r ApiV1CatalogExperiencesCreateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesDestroyRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
}

func (r ApiV1CatalogExperiencesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogExperiencesDestroyExecute(r)
}

/*
V1CatalogExperiencesDestroy Method for V1CatalogExperiencesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiV1CatalogExperiencesDestroyRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesDestroy(ctx context.Context, id string) ApiV1CatalogExperiencesDestroyRequest {
	return ApiV1CatalogExperiencesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesDestroyExecute(r ApiV1CatalogExperiencesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesHistoryListRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	page       *int32
	pageSize   *int32
}

// A page number within the paginated result set.
func (r ApiV1CatalogExperiencesHistoryListRequest) Page(page int32) ApiV1CatalogExperiencesHistoryListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogExperiencesHistoryListRequest) PageSize(pageSize int32) ApiV1CatalogExperiencesHistoryListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1CatalogExperiencesHistoryListRequest) Execute() (*PaginatedModelChangeList, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesHistoryListExecute(r)
}

/*
V1CatalogExperiencesHistoryList Method for V1CatalogExperiencesHistoryList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiV1CatalogExperiencesHistoryListRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesHistoryList(ctx context.Context, id string) ApiV1CatalogExperiencesHistoryListRequest {
	return ApiV1CatalogExperiencesHistoryListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PaginatedModelChangeList
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesHistoryListExecute(r ApiV1CatalogExperiencesHistoryListRequest) (*PaginatedModelChangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedModelChangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesListRequest struct {
	ctx              context.Context
	ApiService       *CatalogExperiencesAPIService
	assignee         *string
	autoapprove      *bool
	autoprovision    *bool
	bootstrap        *bool
	catalogId        *string
	catalogIdAlias   *string
	category         *[]string
	collectionBranch *string
	expand           *string
	experience       *string
	experienceBranch *string
	fields           *string
	garageId         *string
	gcBranch         *string
	gpuCount         *int32
	gpuOsName        *string
	gpuOsRelease     *string
	gpuOsVersion     *string
	id               *string
	nodeCount        *int32
	omit             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	persona          *string
	pipeline         *int32
	platform         *string
	provider         *string
	published        *[]string
	requiresGpu      *string
	saLab            *bool
	search           *string
	systemArch       *string
	vgpuProfile      *string
}

func (r ApiV1CatalogExperiencesListRequest) Assignee(assignee string) ApiV1CatalogExperiencesListRequest {
	r.assignee = &assignee
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Autoapprove(autoapprove bool) ApiV1CatalogExperiencesListRequest {
	r.autoapprove = &autoapprove
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Autoprovision(autoprovision bool) ApiV1CatalogExperiencesListRequest {
	r.autoprovision = &autoprovision
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Bootstrap(bootstrap bool) ApiV1CatalogExperiencesListRequest {
	r.bootstrap = &bootstrap
	return r
}

func (r ApiV1CatalogExperiencesListRequest) CatalogId(catalogId string) ApiV1CatalogExperiencesListRequest {
	r.catalogId = &catalogId
	return r
}

func (r ApiV1CatalogExperiencesListRequest) CatalogIdAlias(catalogIdAlias string) ApiV1CatalogExperiencesListRequest {
	r.catalogIdAlias = &catalogIdAlias
	return r
}

// Multiple values may be separated by commas.  * &#x60;AI&#x60; - AI * &#x60;Clara&#x60; - Clara * &#x60;Data Science&#x60; - Data Science * &#x60;3D Design Collaboration and Simulation&#x60; - 3D Design Collaboration and Simulation * &#x60;Developer&#x60; - Developer * &#x60;Infrastructure Optimization&#x60; - Infrastructure Optimization
func (r ApiV1CatalogExperiencesListRequest) Category(category []string) ApiV1CatalogExperiencesListRequest {
	r.category = &category
	return r
}

func (r ApiV1CatalogExperiencesListRequest) CollectionBranch(collectionBranch string) ApiV1CatalogExperiencesListRequest {
	r.collectionBranch = &collectionBranch
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;required_gpus\&quot;).
func (r ApiV1CatalogExperiencesListRequest) Expand(expand string) ApiV1CatalogExperiencesListRequest {
	r.expand = &expand
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Experience(experience string) ApiV1CatalogExperiencesListRequest {
	r.experience = &experience
	return r
}

func (r ApiV1CatalogExperiencesListRequest) ExperienceBranch(experienceBranch string) ApiV1CatalogExperiencesListRequest {
	r.experienceBranch = &experienceBranch
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogExperiencesListRequest) Fields(fields string) ApiV1CatalogExperiencesListRequest {
	r.fields = &fields
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GarageId(garageId string) ApiV1CatalogExperiencesListRequest {
	r.garageId = &garageId
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GcBranch(gcBranch string) ApiV1CatalogExperiencesListRequest {
	r.gcBranch = &gcBranch
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GpuCount(gpuCount int32) ApiV1CatalogExperiencesListRequest {
	r.gpuCount = &gpuCount
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GpuOsName(gpuOsName string) ApiV1CatalogExperiencesListRequest {
	r.gpuOsName = &gpuOsName
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GpuOsRelease(gpuOsRelease string) ApiV1CatalogExperiencesListRequest {
	r.gpuOsRelease = &gpuOsRelease
	return r
}

func (r ApiV1CatalogExperiencesListRequest) GpuOsVersion(gpuOsVersion string) ApiV1CatalogExperiencesListRequest {
	r.gpuOsVersion = &gpuOsVersion
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Id(id string) ApiV1CatalogExperiencesListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogExperiencesListRequest) NodeCount(nodeCount int32) ApiV1CatalogExperiencesListRequest {
	r.nodeCount = &nodeCount
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogExperiencesListRequest) Omit(omit string) ApiV1CatalogExperiencesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogExperiencesListRequest) Ordering(ordering string) ApiV1CatalogExperiencesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogExperiencesListRequest) Page(page int32) ApiV1CatalogExperiencesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogExperiencesListRequest) PageSize(pageSize int32) ApiV1CatalogExperiencesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Persona(persona string) ApiV1CatalogExperiencesListRequest {
	r.persona = &persona
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Pipeline(pipeline int32) ApiV1CatalogExperiencesListRequest {
	r.pipeline = &pipeline
	return r
}

// Base platform that the experience will be provisioned onto  * &#x60;air&#x60; - NVIDIA Air * &#x60;flight_deck&#x60; - Flight Deck * &#x60;kvm_bastion&#x60; - KVM Bastion * &#x60;lp-vmware-platform&#x60; - lp-vmware-platform * &#x60;minimal&#x60; - minimal * &#x60;openshift&#x60; - OpenShift * &#x60;vsphere&#x60; - vSphere * &#x60;vsphere_horizon&#x60; - VMware Horizon * &#x60;vsphere7&#x60; - vSphere 7 * &#x60;vsphere8&#x60; - vSphere 8
func (r ApiV1CatalogExperiencesListRequest) Platform(platform string) ApiV1CatalogExperiencesListRequest {
	r.platform = &platform
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Provider(provider string) ApiV1CatalogExperiencesListRequest {
	r.provider = &provider
	return r
}

// Multiple values may be separated by commas.  * &#x60;draft&#x60; - draft * &#x60;no&#x60; - no * &#x60;yes&#x60; - yes
func (r ApiV1CatalogExperiencesListRequest) Published(published []string) ApiV1CatalogExperiencesListRequest {
	r.published = &published
	return r
}

// Only include experiences that require a given GPU ID or model
func (r ApiV1CatalogExperiencesListRequest) RequiresGpu(requiresGpu string) ApiV1CatalogExperiencesListRequest {
	r.requiresGpu = &requiresGpu
	return r
}

func (r ApiV1CatalogExperiencesListRequest) SaLab(saLab bool) ApiV1CatalogExperiencesListRequest {
	r.saLab = &saLab
	return r
}

// Search for experiences by assignee, catalog_id, catalog_id_alias, category, collection_branch, description, experience, experience_branch, gc_branch, gpu_os_name, gpu_os_release, gpu_os_version, id, persona, pipeline, platform, provider name, required_gpus model, system_arch, title, vgpu_profile
func (r ApiV1CatalogExperiencesListRequest) Search(search string) ApiV1CatalogExperiencesListRequest {
	r.search = &search
	return r
}

// Required CPU architecture  * &#x60;amd64&#x60; - amd64 * &#x60;arm64&#x60; - arm64
func (r ApiV1CatalogExperiencesListRequest) SystemArch(systemArch string) ApiV1CatalogExperiencesListRequest {
	r.systemArch = &systemArch
	return r
}

// vGPU profile name used by the experience  * &#x60;air&#x60; - NVIDIA Air * &#x60;bright_cluster&#x60; - Bright Cluster * &#x60;bright-cluster&#x60; - Bright Cluster (legacy option) * &#x60;flight_deck&#x60; - Flight Deck * &#x60;flight-deck&#x60; - Flight Deck (legacy option) * &#x60;nvidia_a40-48q&#x60; - nvidia_a40-48q * &#x60;nvidia-ai-enterprise&#x60; - NVIDIA AI Enterprise * &#x60;nvidia_l40s-48q&#x60; - nvidia_l40s-48q * &#x60;nvidia_rtx_pro_6000_blackwell_dc-4-96q&#x60; - nvidia_rtx_pro_6000_blackwell_dc-4-96q * &#x60;nvidia_rtx_pro_6000_blackwell_dc-96q&#x60; - nvidia_rtx_pro_6000_blackwell_dc-96q * &#x60;openshift&#x60; - OpenShift * &#x60;platform_only&#x60; - platform_only * &#x60;vmware_itadmin&#x60; - VMware IT admin
func (r ApiV1CatalogExperiencesListRequest) VgpuProfile(vgpuProfile string) ApiV1CatalogExperiencesListRequest {
	r.vgpuProfile = &vgpuProfile
	return r
}

func (r ApiV1CatalogExperiencesListRequest) Execute() (*PaginatedExperienceList, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesListExecute(r)
}

/*
V1CatalogExperiencesList Method for V1CatalogExperiencesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogExperiencesListRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesList(ctx context.Context) ApiV1CatalogExperiencesListRequest {
	return ApiV1CatalogExperiencesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedExperienceList
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesListExecute(r ApiV1CatalogExperiencesListRequest) (*PaginatedExperienceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedExperienceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "form", "")
	}
	if r.autoapprove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoapprove", r.autoapprove, "form", "")
	}
	if r.autoprovision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoprovision", r.autoprovision, "form", "")
	}
	if r.bootstrap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bootstrap", r.bootstrap, "form", "")
	}
	if r.catalogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalog_id", r.catalogId, "form", "")
	}
	if r.catalogIdAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalog_id_alias", r.catalogIdAlias, "form", "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "csv")
	}
	if r.collectionBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection_branch", r.collectionBranch, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.experienceBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience_branch", r.experienceBranch, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.garageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "garage_id", r.garageId, "form", "")
	}
	if r.gcBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gc_branch", r.gcBranch, "form", "")
	}
	if r.gpuCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_count", r.gpuCount, "form", "")
	}
	if r.gpuOsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_name", r.gpuOsName, "form", "")
	}
	if r.gpuOsRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_release", r.gpuOsRelease, "form", "")
	}
	if r.gpuOsVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_version", r.gpuOsVersion, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.nodeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_count", r.nodeCount, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.persona != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persona", r.persona, "form", "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "form", "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	}
	if r.published != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "published", r.published, "form", "csv")
	}
	if r.requiresGpu != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requires_gpu", r.requiresGpu, "form", "")
	}
	if r.saLab != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lab", r.saLab, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.systemArch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "system_arch", r.systemArch, "form", "")
	}
	if r.vgpuProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vgpu_profile", r.vgpuProfile, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesPartialUpdateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	experience *Experience
}

func (r ApiV1CatalogExperiencesPartialUpdateRequest) Experience(experience Experience) ApiV1CatalogExperiencesPartialUpdateRequest {
	r.experience = &experience
	return r
}

func (r ApiV1CatalogExperiencesPartialUpdateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesPartialUpdateExecute(r)
}

/*
V1CatalogExperiencesPartialUpdate Method for V1CatalogExperiencesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiV1CatalogExperiencesPartialUpdateRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesPartialUpdate(ctx context.Context, id string) ApiV1CatalogExperiencesPartialUpdateRequest {
	return ApiV1CatalogExperiencesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesPartialUpdateExecute(r ApiV1CatalogExperiencesPartialUpdateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	expand     *string
	fields     *string
	omit       *string
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;required_gpus\&quot;).
func (r ApiV1CatalogExperiencesRetrieveRequest) Expand(expand string) ApiV1CatalogExperiencesRetrieveRequest {
	r.expand = &expand
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogExperiencesRetrieveRequest) Fields(fields string) ApiV1CatalogExperiencesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogExperiencesRetrieveRequest) Omit(omit string) ApiV1CatalogExperiencesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiV1CatalogExperiencesRetrieveRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesRetrieveExecute(r)
}

/*
V1CatalogExperiencesRetrieve Method for V1CatalogExperiencesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiV1CatalogExperiencesRetrieveRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesRetrieve(ctx context.Context, id string) ApiV1CatalogExperiencesRetrieveRequest {
	return ApiV1CatalogExperiencesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesRetrieveExecute(r ApiV1CatalogExperiencesRetrieveRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesStatsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
}

func (r ApiV1CatalogExperiencesStatsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogExperiencesStatsRetrieveExecute(r)
}

/*
V1CatalogExperiencesStatsRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogExperiencesStatsRetrieveRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesStatsRetrieve(ctx context.Context) ApiV1CatalogExperiencesStatsRetrieveRequest {
	return ApiV1CatalogExperiencesStatsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesStatsRetrieveExecute(r ApiV1CatalogExperiencesStatsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesStatsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesUpdateRequest struct {
	ctx        context.Context
	ApiService *CatalogExperiencesAPIService
	id         string
	experience *Experience
}

func (r ApiV1CatalogExperiencesUpdateRequest) Experience(experience Experience) ApiV1CatalogExperiencesUpdateRequest {
	r.experience = &experience
	return r
}

func (r ApiV1CatalogExperiencesUpdateRequest) Execute() (*Experience, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesUpdateExecute(r)
}

/*
V1CatalogExperiencesUpdate Method for V1CatalogExperiencesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this experience.
	@return ApiV1CatalogExperiencesUpdateRequest
*/
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesUpdate(ctx context.Context, id string) ApiV1CatalogExperiencesUpdateRequest {
	return ApiV1CatalogExperiencesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Experience
func (a *CatalogExperiencesAPIService) V1CatalogExperiencesUpdateExecute(r ApiV1CatalogExperiencesUpdateRequest) (*Experience, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Experience
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogExperiencesAPIService.V1CatalogExperiencesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experience == nil {
		return localVarReturnValue, nil, reportError("experience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experience
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
