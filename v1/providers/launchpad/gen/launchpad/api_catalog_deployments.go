/*
NVIDIA LaunchPad API

RESTful API for interacting with the NVIDIA LaunchPad platform

API version: 2.39.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CatalogDeploymentsAPIService CatalogDeploymentsAPI service
type CatalogDeploymentsAPIService service

type ApiV1CatalogDeploymentsBulkPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *CatalogDeploymentsAPIService
	deploymentBulkUpdate *DeploymentBulkUpdate
}

func (r ApiV1CatalogDeploymentsBulkPartialUpdateRequest) DeploymentBulkUpdate(deploymentBulkUpdate DeploymentBulkUpdate) ApiV1CatalogDeploymentsBulkPartialUpdateRequest {
	r.deploymentBulkUpdate = &deploymentBulkUpdate
	return r
}

func (r ApiV1CatalogDeploymentsBulkPartialUpdateRequest) Execute() (*DeploymentBulkUpdate, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsBulkPartialUpdateExecute(r)
}

/*
V1CatalogDeploymentsBulkPartialUpdate Method for V1CatalogDeploymentsBulkPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogDeploymentsBulkPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsBulkPartialUpdate(ctx context.Context) ApiV1CatalogDeploymentsBulkPartialUpdateRequest {
	return ApiV1CatalogDeploymentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeploymentBulkUpdate
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsBulkPartialUpdateExecute(r ApiV1CatalogDeploymentsBulkPartialUpdateRequest) (*DeploymentBulkUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentBulkUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentBulkUpdate == nil {
		return localVarReturnValue, nil, reportError("deploymentBulkUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentBulkUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	deployment *Deployment
	expand     *string
}

func (r ApiV1CatalogDeploymentsCreateRequest) Deployment(deployment Deployment) ApiV1CatalogDeploymentsCreateRequest {
	r.deployment = &deployment
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiV1CatalogDeploymentsCreateRequest) Expand(expand string) ApiV1CatalogDeploymentsCreateRequest {
	r.expand = &expand
	return r
}

func (r ApiV1CatalogDeploymentsCreateRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsCreateExecute(r)
}

/*
V1CatalogDeploymentsCreate Method for V1CatalogDeploymentsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogDeploymentsCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsCreate(ctx context.Context) ApiV1CatalogDeploymentsCreateRequest {
	return ApiV1CatalogDeploymentsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Deployment
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsCreateExecute(r ApiV1CatalogDeploymentsCreateRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deployment == nil {
		return localVarReturnValue, nil, reportError("deployment is required and must be specified")
	}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deployment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsDestroyRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
}

func (r ApiV1CatalogDeploymentsDestroyRequest) Execute() (*DocDeploymentDelete, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsDestroyExecute(r)
}

/*
V1CatalogDeploymentsDestroy Method for V1CatalogDeploymentsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiV1CatalogDeploymentsDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsDestroy(ctx context.Context, id string) ApiV1CatalogDeploymentsDestroyRequest {
	return ApiV1CatalogDeploymentsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DocDeploymentDelete
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsDestroyExecute(r ApiV1CatalogDeploymentsDestroyRequest) (*DocDeploymentDelete, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DocDeploymentDelete
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsDestroy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsHistoryListRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
	page       *int32
	pageSize   *int32
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsHistoryListRequest) Page(page int32) ApiV1CatalogDeploymentsHistoryListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsHistoryListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsHistoryListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1CatalogDeploymentsHistoryListRequest) Execute() (*PaginatedModelChangeList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsHistoryListExecute(r)
}

/*
V1CatalogDeploymentsHistoryList Method for V1CatalogDeploymentsHistoryList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiV1CatalogDeploymentsHistoryListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsHistoryList(ctx context.Context, id string) ApiV1CatalogDeploymentsHistoryListRequest {
	return ApiV1CatalogDeploymentsHistoryListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PaginatedModelChangeList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsHistoryListExecute(r ApiV1CatalogDeploymentsHistoryListRequest) (*PaginatedModelChangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedModelChangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsInstancesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	fields       *string
	id           *string
	instanceId   *string
	name         *string
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
	state        *string
}

// Include only the specified fields in the response
func (r ApiV1CatalogDeploymentsInstancesListRequest) Fields(fields string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.fields = &fields
	return r
}

func (r ApiV1CatalogDeploymentsInstancesListRequest) Id(id string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogDeploymentsInstancesListRequest) InstanceId(instanceId string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.instanceId = &instanceId
	return r
}

func (r ApiV1CatalogDeploymentsInstancesListRequest) Name(name string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.name = &name
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogDeploymentsInstancesListRequest) Omit(omit string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsInstancesListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsInstancesListRequest) Page(page int32) ApiV1CatalogDeploymentsInstancesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsInstancesListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsInstancesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-instances by id, instance_id, name, state, tags
func (r ApiV1CatalogDeploymentsInstancesListRequest) Search(search string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.search = &search
	return r
}

// Current lifecycle state of this instance  * &#x60;running&#x60; - Instance is running * &#x60;starting&#x60; - Instance is starting * &#x60;stopped&#x60; - Instance is stopped * &#x60;stopping&#x60; - Instance is stopping * &#x60;unknown&#x60; - Instance state is currently unknown
func (r ApiV1CatalogDeploymentsInstancesListRequest) State(state string) ApiV1CatalogDeploymentsInstancesListRequest {
	r.state = &state
	return r
}

func (r ApiV1CatalogDeploymentsInstancesListRequest) Execute() (*PaginatedDeploymentInstanceList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsInstancesListExecute(r)
}

/*
V1CatalogDeploymentsInstancesList ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsInstancesListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsInstancesList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsInstancesListRequest {
	return ApiV1CatalogDeploymentsInstancesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentInstanceList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsInstancesListExecute(r ApiV1CatalogDeploymentsInstancesListRequest) (*PaginatedDeploymentInstanceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentInstanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsInstancesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/instances/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsListRequest struct {
	ctx                     context.Context
	ApiService              *CatalogDeploymentsAPIService
	bastionOperatingSystem  *string
	cluster                 *string
	clusterGpusModel        *[]string
	collectionBranch        *string
	expand                  *string
	experience              *string
	experienceBranch        *string
	expired                 *bool
	expiresAt               *string
	expiring                *string
	fields                  *string
	flightcontrolRelease    *string
	garageId                *string
	gcBranch                *string
	gpuAlias                *string
	gpuCount                *int32
	gpuModel                *string
	gpuOsName               *string
	gpuOsRelease            *string
	gpuOsVersion            *string
	id                      *string
	nodeCount               *int32
	oemName                 *string
	omit                    *string
	ordering                *string
	orgName                 *string
	page                    *int32
	pageSize                *int32
	persistOnFailure        *bool
	persona                 *string
	pipeline                *int32
	pipelineBranch          *string
	platform                *string
	priority                *string
	providerName            *string
	region                  *string
	requestId               *string
	requesterEmail          *string
	requesterName           *string
	runtimeBranch           *string
	runtimeCnsAddonPack     *bool
	runtimeCnsDocker        *bool
	runtimeCnsDriverVersion *string
	runtimeCnsK8s           *bool
	runtimeCnsNvidiaDriver  *bool
	runtimeCnsVersion       *string
	runtimeMig              *bool
	runtimeMigProfile       *string
	salesId                 *string
	salesOwnerEmail         *string
	salesOwnerName          *string
	search                  *string
	state                   *[]string
	stateNot                *[]string
	workshop                *bool
	workshopId              *string
}

func (r ApiV1CatalogDeploymentsListRequest) BastionOperatingSystem(bastionOperatingSystem string) ApiV1CatalogDeploymentsListRequest {
	r.bastionOperatingSystem = &bastionOperatingSystem
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Cluster(cluster string) ApiV1CatalogDeploymentsListRequest {
	r.cluster = &cluster
	return r
}

// Multiple values may be separated by commas.
func (r ApiV1CatalogDeploymentsListRequest) ClusterGpusModel(clusterGpusModel []string) ApiV1CatalogDeploymentsListRequest {
	r.clusterGpusModel = &clusterGpusModel
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) CollectionBranch(collectionBranch string) ApiV1CatalogDeploymentsListRequest {
	r.collectionBranch = &collectionBranch
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiV1CatalogDeploymentsListRequest) Expand(expand string) ApiV1CatalogDeploymentsListRequest {
	r.expand = &expand
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Experience(experience string) ApiV1CatalogDeploymentsListRequest {
	r.experience = &experience
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) ExperienceBranch(experienceBranch string) ApiV1CatalogDeploymentsListRequest {
	r.experienceBranch = &experienceBranch
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Expired(expired bool) ApiV1CatalogDeploymentsListRequest {
	r.expired = &expired
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) ExpiresAt(expiresAt string) ApiV1CatalogDeploymentsListRequest {
	r.expiresAt = &expiresAt
	return r
}

// Include deployments whose expires_at value is within the given range (inclusive), specified as \&quot;today\&quot;, \&quot;tomorrow\&quot;, or \&quot;{start}[,end]\&quot;. Start and end times must be in ISO format.
func (r ApiV1CatalogDeploymentsListRequest) Expiring(expiring string) ApiV1CatalogDeploymentsListRequest {
	r.expiring = &expiring
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogDeploymentsListRequest) Fields(fields string) ApiV1CatalogDeploymentsListRequest {
	r.fields = &fields
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) FlightcontrolRelease(flightcontrolRelease string) ApiV1CatalogDeploymentsListRequest {
	r.flightcontrolRelease = &flightcontrolRelease
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GarageId(garageId string) ApiV1CatalogDeploymentsListRequest {
	r.garageId = &garageId
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GcBranch(gcBranch string) ApiV1CatalogDeploymentsListRequest {
	r.gcBranch = &gcBranch
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuAlias(gpuAlias string) ApiV1CatalogDeploymentsListRequest {
	r.gpuAlias = &gpuAlias
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuCount(gpuCount int32) ApiV1CatalogDeploymentsListRequest {
	r.gpuCount = &gpuCount
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuModel(gpuModel string) ApiV1CatalogDeploymentsListRequest {
	r.gpuModel = &gpuModel
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuOsName(gpuOsName string) ApiV1CatalogDeploymentsListRequest {
	r.gpuOsName = &gpuOsName
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuOsRelease(gpuOsRelease string) ApiV1CatalogDeploymentsListRequest {
	r.gpuOsRelease = &gpuOsRelease
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) GpuOsVersion(gpuOsVersion string) ApiV1CatalogDeploymentsListRequest {
	r.gpuOsVersion = &gpuOsVersion
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Id(id string) ApiV1CatalogDeploymentsListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) NodeCount(nodeCount int32) ApiV1CatalogDeploymentsListRequest {
	r.nodeCount = &nodeCount
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) OemName(oemName string) ApiV1CatalogDeploymentsListRequest {
	r.oemName = &oemName
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogDeploymentsListRequest) Omit(omit string) ApiV1CatalogDeploymentsListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) OrgName(orgName string) ApiV1CatalogDeploymentsListRequest {
	r.orgName = &orgName
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsListRequest) Page(page int32) ApiV1CatalogDeploymentsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) PersistOnFailure(persistOnFailure bool) ApiV1CatalogDeploymentsListRequest {
	r.persistOnFailure = &persistOnFailure
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Persona(persona string) ApiV1CatalogDeploymentsListRequest {
	r.persona = &persona
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Pipeline(pipeline int32) ApiV1CatalogDeploymentsListRequest {
	r.pipeline = &pipeline
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) PipelineBranch(pipelineBranch string) ApiV1CatalogDeploymentsListRequest {
	r.pipelineBranch = &pipelineBranch
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Platform(platform string) ApiV1CatalogDeploymentsListRequest {
	r.platform = &platform
	return r
}

// Priority level for the request  * &#x60;p0&#x60; - p0 * &#x60;p1&#x60; - p1 * &#x60;p2&#x60; - p2 * &#x60;p3&#x60; - p3
func (r ApiV1CatalogDeploymentsListRequest) Priority(priority string) ApiV1CatalogDeploymentsListRequest {
	r.priority = &priority
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) ProviderName(providerName string) ApiV1CatalogDeploymentsListRequest {
	r.providerName = &providerName
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Region(region string) ApiV1CatalogDeploymentsListRequest {
	r.region = &region
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RequestId(requestId string) ApiV1CatalogDeploymentsListRequest {
	r.requestId = &requestId
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RequesterEmail(requesterEmail string) ApiV1CatalogDeploymentsListRequest {
	r.requesterEmail = &requesterEmail
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RequesterName(requesterName string) ApiV1CatalogDeploymentsListRequest {
	r.requesterName = &requesterName
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeBranch(runtimeBranch string) ApiV1CatalogDeploymentsListRequest {
	r.runtimeBranch = &runtimeBranch
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsAddonPack(runtimeCnsAddonPack bool) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsAddonPack = &runtimeCnsAddonPack
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsDocker(runtimeCnsDocker bool) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsDocker = &runtimeCnsDocker
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsDriverVersion(runtimeCnsDriverVersion string) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsDriverVersion = &runtimeCnsDriverVersion
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsK8s(runtimeCnsK8s bool) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsK8s = &runtimeCnsK8s
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsNvidiaDriver(runtimeCnsNvidiaDriver bool) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsNvidiaDriver = &runtimeCnsNvidiaDriver
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeCnsVersion(runtimeCnsVersion string) ApiV1CatalogDeploymentsListRequest {
	r.runtimeCnsVersion = &runtimeCnsVersion
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeMig(runtimeMig bool) ApiV1CatalogDeploymentsListRequest {
	r.runtimeMig = &runtimeMig
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) RuntimeMigProfile(runtimeMigProfile string) ApiV1CatalogDeploymentsListRequest {
	r.runtimeMigProfile = &runtimeMigProfile
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) SalesId(salesId string) ApiV1CatalogDeploymentsListRequest {
	r.salesId = &salesId
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) SalesOwnerEmail(salesOwnerEmail string) ApiV1CatalogDeploymentsListRequest {
	r.salesOwnerEmail = &salesOwnerEmail
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) SalesOwnerName(salesOwnerName string) ApiV1CatalogDeploymentsListRequest {
	r.salesOwnerName = &salesOwnerName
	return r
}

// Search for deployments by experience catalog_id, experience catalog_id_alias, experience id, experience title, expires_at, id, org_name, provisioning_config bastion_operating_system, provisioning_config collection_branch, provisioning_config experience_branch, provisioning_config flightcontrol_release, provisioning_config garage_id, provisioning_config gc_branch, provisioning_config gpu_alias, provisioning_config gpu_model, provisioning_config gpu_os_name, provisioning_config gpu_os_release, provisioning_config gpu_os_version, provisioning_config oem_name, provisioning_config persona, provisioning_config pipeline_branch, provisioning_config platform, provisioning_config provider_name, provisioning_config region, provisioning_config runtime_branch, provisioning_config runtime_cns_driver_version, provisioning_config runtime_cns_version, provisioning_config runtime_mig_profile, provisioning_config runtime_url, provisioning_config workshop_id, provisioning_request bastion_operating_system, provisioning_request collection_branch, provisioning_request experience_branch, provisioning_request flightcontrol_release, provisioning_request garage_id, provisioning_request gc_branch, provisioning_request gpu_alias, provisioning_request gpu_model, provisioning_request gpu_os_name, provisioning_request gpu_os_release, provisioning_request gpu_os_version, provisioning_request oem_name, provisioning_request persona, provisioning_request pipeline_branch, provisioning_request platform, provisioning_request provider_name, provisioning_request region, provisioning_request runtime_branch, provisioning_request runtime_cns_driver_version, provisioning_request runtime_cns_version, provisioning_request runtime_mig_profile, provisioning_request runtime_url, provisioning_request workshop_id, request_id, requester_email, requester_name, sales_id, sales_owner_email, sales_owner_name, services url, state, tags
func (r ApiV1CatalogDeploymentsListRequest) Search(search string) ApiV1CatalogDeploymentsListRequest {
	r.search = &search
	return r
}

// Multiple values may be separated by commas.  * &#x60;destroyed&#x60; - Deployment has been fully destroyed * &#x60;destroying&#x60; - Deployment is being destroyed * &#x60;error&#x60; - Deployment has encountered a fatal error and will not be retried * &#x60;failed&#x60; - Deployment has failed but may be retried * &#x60;paused&#x60; - Deployment is paused but may be retried later * &#x60;ready&#x60; - Deployment is ready and all instances are running * &#x60;retrying&#x60; - Deployment is retrying * &#x60;starting&#x60; - Deployment instances are starting * &#x60;stopped&#x60; - Deployment instances are stopped * &#x60;stopping&#x60; - Deployment instances are stopping * &#x60;waiting&#x60; - Waiting for deployment to be ready
func (r ApiV1CatalogDeploymentsListRequest) State(state []string) ApiV1CatalogDeploymentsListRequest {
	r.state = &state
	return r
}

// Multiple values may be separated by commas.  * &#x60;destroyed&#x60; - Deployment has been fully destroyed * &#x60;destroying&#x60; - Deployment is being destroyed * &#x60;error&#x60; - Deployment has encountered a fatal error and will not be retried * &#x60;failed&#x60; - Deployment has failed but may be retried * &#x60;paused&#x60; - Deployment is paused but may be retried later * &#x60;ready&#x60; - Deployment is ready and all instances are running * &#x60;retrying&#x60; - Deployment is retrying * &#x60;starting&#x60; - Deployment instances are starting * &#x60;stopped&#x60; - Deployment instances are stopped * &#x60;stopping&#x60; - Deployment instances are stopping * &#x60;waiting&#x60; - Waiting for deployment to be ready
func (r ApiV1CatalogDeploymentsListRequest) StateNot(stateNot []string) ApiV1CatalogDeploymentsListRequest {
	r.stateNot = &stateNot
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Workshop(workshop bool) ApiV1CatalogDeploymentsListRequest {
	r.workshop = &workshop
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) WorkshopId(workshopId string) ApiV1CatalogDeploymentsListRequest {
	r.workshopId = &workshopId
	return r
}

func (r ApiV1CatalogDeploymentsListRequest) Execute() (*PaginatedDeploymentList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsListExecute(r)
}

/*
V1CatalogDeploymentsList Method for V1CatalogDeploymentsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogDeploymentsListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsList(ctx context.Context) ApiV1CatalogDeploymentsListRequest {
	return ApiV1CatalogDeploymentsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsListExecute(r ApiV1CatalogDeploymentsListRequest) (*PaginatedDeploymentList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bastionOperatingSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bastion_operating_system", r.bastionOperatingSystem, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.clusterGpusModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_gpus_model", r.clusterGpusModel, "form", "csv")
	}
	if r.collectionBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection_branch", r.collectionBranch, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.experienceBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience_branch", r.experienceBranch, "form", "")
	}
	if r.expired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expired", r.expired, "form", "")
	}
	if r.expiresAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires_at", r.expiresAt, "form", "")
	}
	if r.expiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiring", r.expiring, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.flightcontrolRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flightcontrol_release", r.flightcontrolRelease, "form", "")
	}
	if r.garageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "garage_id", r.garageId, "form", "")
	}
	if r.gcBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gc_branch", r.gcBranch, "form", "")
	}
	if r.gpuAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_alias", r.gpuAlias, "form", "")
	}
	if r.gpuCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_count", r.gpuCount, "form", "")
	}
	if r.gpuModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_model", r.gpuModel, "form", "")
	}
	if r.gpuOsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_name", r.gpuOsName, "form", "")
	}
	if r.gpuOsRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_release", r.gpuOsRelease, "form", "")
	}
	if r.gpuOsVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_version", r.gpuOsVersion, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.nodeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_count", r.nodeCount, "form", "")
	}
	if r.oemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oem_name", r.oemName, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.orgName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "org_name", r.orgName, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.persistOnFailure != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persist_on_failure", r.persistOnFailure, "form", "")
	}
	if r.persona != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persona", r.persona, "form", "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "form", "")
	}
	if r.pipelineBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline_branch", r.pipelineBranch, "form", "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "form", "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "form", "")
	}
	if r.providerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider_name", r.providerName, "form", "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "form", "")
	}
	if r.requesterEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester_email", r.requesterEmail, "form", "")
	}
	if r.requesterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester_name", r.requesterName, "form", "")
	}
	if r.runtimeBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_branch", r.runtimeBranch, "form", "")
	}
	if r.runtimeCnsAddonPack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_addon_pack", r.runtimeCnsAddonPack, "form", "")
	}
	if r.runtimeCnsDocker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_docker", r.runtimeCnsDocker, "form", "")
	}
	if r.runtimeCnsDriverVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_driver_version", r.runtimeCnsDriverVersion, "form", "")
	}
	if r.runtimeCnsK8s != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_k8s", r.runtimeCnsK8s, "form", "")
	}
	if r.runtimeCnsNvidiaDriver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_nvidia_driver", r.runtimeCnsNvidiaDriver, "form", "")
	}
	if r.runtimeCnsVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_cns_version", r.runtimeCnsVersion, "form", "")
	}
	if r.runtimeMig != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_mig", r.runtimeMig, "form", "")
	}
	if r.runtimeMigProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime_mig_profile", r.runtimeMigProfile, "form", "")
	}
	if r.salesId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_id", r.salesId, "form", "")
	}
	if r.salesOwnerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_owner_email", r.salesOwnerEmail, "form", "")
	}
	if r.salesOwnerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_owner_name", r.salesOwnerName, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.stateNot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state_not", r.stateNot, "form", "csv")
	}
	if r.workshop != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workshop", r.workshop, "form", "")
	}
	if r.workshopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workshop_id", r.workshopId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	deploymentNote *DeploymentNote
}

func (r ApiV1CatalogDeploymentsNotesCreateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiV1CatalogDeploymentsNotesCreateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiV1CatalogDeploymentsNotesCreateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesCreateExecute(r)
}

/*
V1CatalogDeploymentsNotesCreate Method for V1CatalogDeploymentsNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsNotesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesCreate(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsNotesCreateRequest {
	return ApiV1CatalogDeploymentsNotesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesCreateExecute(r ApiV1CatalogDeploymentsNotesCreateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiV1CatalogDeploymentsNotesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesDestroyExecute(r)
}

/*
V1CatalogDeploymentsNotesDestroy Method for V1CatalogDeploymentsNotesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsNotesDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesDestroy(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsNotesDestroyRequest {
	return ApiV1CatalogDeploymentsNotesDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesDestroyExecute(r ApiV1CatalogDeploymentsNotesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	createdBy    *int32
	deployment   *string
	fields       *string
	id           *string
	modifiedBy   *int32
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiV1CatalogDeploymentsNotesListRequest) CreatedBy(createdBy int32) ApiV1CatalogDeploymentsNotesListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiV1CatalogDeploymentsNotesListRequest) Deployment(deployment string) ApiV1CatalogDeploymentsNotesListRequest {
	r.deployment = &deployment
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogDeploymentsNotesListRequest) Fields(fields string) ApiV1CatalogDeploymentsNotesListRequest {
	r.fields = &fields
	return r
}

func (r ApiV1CatalogDeploymentsNotesListRequest) Id(id string) ApiV1CatalogDeploymentsNotesListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogDeploymentsNotesListRequest) ModifiedBy(modifiedBy int32) ApiV1CatalogDeploymentsNotesListRequest {
	r.modifiedBy = &modifiedBy
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogDeploymentsNotesListRequest) Omit(omit string) ApiV1CatalogDeploymentsNotesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsNotesListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsNotesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsNotesListRequest) Page(page int32) ApiV1CatalogDeploymentsNotesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsNotesListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsNotesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-notes by content
func (r ApiV1CatalogDeploymentsNotesListRequest) Search(search string) ApiV1CatalogDeploymentsNotesListRequest {
	r.search = &search
	return r
}

func (r ApiV1CatalogDeploymentsNotesListRequest) Execute() (*PaginatedDeploymentNoteList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesListExecute(r)
}

/*
V1CatalogDeploymentsNotesList Method for V1CatalogDeploymentsNotesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsNotesListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsNotesListRequest {
	return ApiV1CatalogDeploymentsNotesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentNoteList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesListExecute(r ApiV1CatalogDeploymentsNotesListRequest) (*PaginatedDeploymentNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.deployment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployment", r.deployment, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.modifiedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by", r.modifiedBy, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	id             string
	deploymentNote *DeploymentNote
}

func (r ApiV1CatalogDeploymentsNotesPartialUpdateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiV1CatalogDeploymentsNotesPartialUpdateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiV1CatalogDeploymentsNotesPartialUpdateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesPartialUpdateExecute(r)
}

/*
V1CatalogDeploymentsNotesPartialUpdate Method for V1CatalogDeploymentsNotesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsNotesPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesPartialUpdate(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsNotesPartialUpdateRequest {
	return ApiV1CatalogDeploymentsNotesPartialUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesPartialUpdateExecute(r ApiV1CatalogDeploymentsNotesPartialUpdateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
	fields       *string
	omit         *string
}

// Include only the specified fields in the response
func (r ApiV1CatalogDeploymentsNotesRetrieveRequest) Fields(fields string) ApiV1CatalogDeploymentsNotesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogDeploymentsNotesRetrieveRequest) Omit(omit string) ApiV1CatalogDeploymentsNotesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiV1CatalogDeploymentsNotesRetrieveRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesRetrieveExecute(r)
}

/*
V1CatalogDeploymentsNotesRetrieve Method for V1CatalogDeploymentsNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsNotesRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesRetrieve(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsNotesRetrieveRequest {
	return ApiV1CatalogDeploymentsNotesRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesRetrieveExecute(r ApiV1CatalogDeploymentsNotesRetrieveRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsNotesUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	id             string
	deploymentNote *DeploymentNote
}

func (r ApiV1CatalogDeploymentsNotesUpdateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiV1CatalogDeploymentsNotesUpdateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiV1CatalogDeploymentsNotesUpdateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsNotesUpdateExecute(r)
}

/*
V1CatalogDeploymentsNotesUpdate Method for V1CatalogDeploymentsNotesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsNotesUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesUpdate(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsNotesUpdateRequest {
	return ApiV1CatalogDeploymentsNotesUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsNotesUpdateExecute(r ApiV1CatalogDeploymentsNotesUpdateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsNotesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *CatalogDeploymentsAPIService
	id               string
	deploymentUpdate *DeploymentUpdate
}

func (r ApiV1CatalogDeploymentsPartialUpdateRequest) DeploymentUpdate(deploymentUpdate DeploymentUpdate) ApiV1CatalogDeploymentsPartialUpdateRequest {
	r.deploymentUpdate = &deploymentUpdate
	return r
}

func (r ApiV1CatalogDeploymentsPartialUpdateRequest) Execute() (*DeploymentUpdate, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsPartialUpdateExecute(r)
}

/*
V1CatalogDeploymentsPartialUpdate Method for V1CatalogDeploymentsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiV1CatalogDeploymentsPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPartialUpdate(ctx context.Context, id string) ApiV1CatalogDeploymentsPartialUpdateRequest {
	return ApiV1CatalogDeploymentsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeploymentUpdate
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPartialUpdateExecute(r ApiV1CatalogDeploymentsPartialUpdateRequest) (*DeploymentUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsPipelinesCreateRequest struct {
	ctx                context.Context
	ApiService         *CatalogDeploymentsAPIService
	deploymentId       string
	deploymentPipeline *DeploymentPipeline
}

func (r ApiV1CatalogDeploymentsPipelinesCreateRequest) DeploymentPipeline(deploymentPipeline DeploymentPipeline) ApiV1CatalogDeploymentsPipelinesCreateRequest {
	r.deploymentPipeline = &deploymentPipeline
	return r
}

func (r ApiV1CatalogDeploymentsPipelinesCreateRequest) Execute() (*DeploymentPipeline, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsPipelinesCreateExecute(r)
}

/*
V1CatalogDeploymentsPipelinesCreate Method for V1CatalogDeploymentsPipelinesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsPipelinesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPipelinesCreate(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsPipelinesCreateRequest {
	return ApiV1CatalogDeploymentsPipelinesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentPipeline
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPipelinesCreateExecute(r ApiV1CatalogDeploymentsPipelinesCreateRequest) (*DeploymentPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsPipelinesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentPipeline == nil {
		return localVarReturnValue, nil, reportError("deploymentPipeline is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentPipeline
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsPipelinesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	action       *string
	id           *string
	ordering     *string
	page         *int32
	pageSize     *int32
	pipelineId   *int32
	search       *string
}

// Action for the pipeline to run  * &#x60;apply&#x60; - apply * &#x60;destroy&#x60; - destroy * &#x60;notify&#x60; - notify
func (r ApiV1CatalogDeploymentsPipelinesListRequest) Action(action string) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.action = &action
	return r
}

func (r ApiV1CatalogDeploymentsPipelinesListRequest) Id(id string) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.id = &id
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsPipelinesListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsPipelinesListRequest) Page(page int32) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsPipelinesListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1CatalogDeploymentsPipelinesListRequest) PipelineId(pipelineId int32) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.pipelineId = &pipelineId
	return r
}

// Search for deployment-pipelines by action, id, pipeline_id, url
func (r ApiV1CatalogDeploymentsPipelinesListRequest) Search(search string) ApiV1CatalogDeploymentsPipelinesListRequest {
	r.search = &search
	return r
}

func (r ApiV1CatalogDeploymentsPipelinesListRequest) Execute() (*PaginatedDeploymentPipelineList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsPipelinesListExecute(r)
}

/*
V1CatalogDeploymentsPipelinesList Method for V1CatalogDeploymentsPipelinesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsPipelinesListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPipelinesList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsPipelinesListRequest {
	return ApiV1CatalogDeploymentsPipelinesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentPipelineList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsPipelinesListExecute(r ApiV1CatalogDeploymentsPipelinesListRequest) (*PaginatedDeploymentPipelineList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentPipelineList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsPipelinesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pipelineId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline_id", r.pipelineId, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
	expand     *string
	expiring   *string
	fields     *string
	omit       *string
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiV1CatalogDeploymentsRetrieveRequest) Expand(expand string) ApiV1CatalogDeploymentsRetrieveRequest {
	r.expand = &expand
	return r
}

// Include deployments whose expires_at value is within the given range (inclusive), specified as \&quot;today\&quot;, \&quot;tomorrow\&quot;, or \&quot;{start}[,end]\&quot;. Start and end times must be in ISO format.
func (r ApiV1CatalogDeploymentsRetrieveRequest) Expiring(expiring string) ApiV1CatalogDeploymentsRetrieveRequest {
	r.expiring = &expiring
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogDeploymentsRetrieveRequest) Fields(fields string) ApiV1CatalogDeploymentsRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogDeploymentsRetrieveRequest) Omit(omit string) ApiV1CatalogDeploymentsRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiV1CatalogDeploymentsRetrieveRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsRetrieveExecute(r)
}

/*
V1CatalogDeploymentsRetrieve Method for V1CatalogDeploymentsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiV1CatalogDeploymentsRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsRetrieve(ctx context.Context, id string) ApiV1CatalogDeploymentsRetrieveRequest {
	return ApiV1CatalogDeploymentsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Deployment
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsRetrieveExecute(r ApiV1CatalogDeploymentsRetrieveRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.expiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiring", r.expiring, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsServicesCreateRequest struct {
	ctx               context.Context
	ApiService        *CatalogDeploymentsAPIService
	deploymentId      string
	deploymentService *DeploymentService
}

func (r ApiV1CatalogDeploymentsServicesCreateRequest) DeploymentService(deploymentService DeploymentService) ApiV1CatalogDeploymentsServicesCreateRequest {
	r.deploymentService = &deploymentService
	return r
}

func (r ApiV1CatalogDeploymentsServicesCreateRequest) Execute() (*DeploymentService, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsServicesCreateExecute(r)
}

/*
V1CatalogDeploymentsServicesCreate Method for V1CatalogDeploymentsServicesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsServicesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsServicesCreate(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsServicesCreateRequest {
	return ApiV1CatalogDeploymentsServicesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentService
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsServicesCreateExecute(r ApiV1CatalogDeploymentsServicesCreateRequest) (*DeploymentService, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/services/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentService == nil {
		return localVarReturnValue, nil, reportError("deploymentService is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsServicesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           *string
	name         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiV1CatalogDeploymentsServicesListRequest) Id(id string) ApiV1CatalogDeploymentsServicesListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogDeploymentsServicesListRequest) Name(name string) ApiV1CatalogDeploymentsServicesListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsServicesListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsServicesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsServicesListRequest) Page(page int32) ApiV1CatalogDeploymentsServicesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsServicesListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsServicesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-services by id, name, url
func (r ApiV1CatalogDeploymentsServicesListRequest) Search(search string) ApiV1CatalogDeploymentsServicesListRequest {
	r.search = &search
	return r
}

func (r ApiV1CatalogDeploymentsServicesListRequest) Execute() (*PaginatedDeploymentServiceList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsServicesListExecute(r)
}

/*
V1CatalogDeploymentsServicesList Method for V1CatalogDeploymentsServicesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsServicesListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsServicesList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsServicesListRequest {
	return ApiV1CatalogDeploymentsServicesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentServiceList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsServicesListExecute(r ApiV1CatalogDeploymentsServicesListRequest) (*PaginatedDeploymentServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/services/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsSshKeysCreateRequest struct {
	ctx           context.Context
	ApiService    *CatalogDeploymentsAPIService
	deploymentId  string
	deploymentKey *DeploymentKey
}

func (r ApiV1CatalogDeploymentsSshKeysCreateRequest) DeploymentKey(deploymentKey DeploymentKey) ApiV1CatalogDeploymentsSshKeysCreateRequest {
	r.deploymentKey = &deploymentKey
	return r
}

func (r ApiV1CatalogDeploymentsSshKeysCreateRequest) Execute() (*DeploymentKey, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsSshKeysCreateExecute(r)
}

/*
V1CatalogDeploymentsSshKeysCreate Method for V1CatalogDeploymentsSshKeysCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsSshKeysCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysCreate(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsSshKeysCreateRequest {
	return ApiV1CatalogDeploymentsSshKeysCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentKey
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysCreateExecute(r ApiV1CatalogDeploymentsSshKeysCreateRequest) (*DeploymentKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsSshKeysCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentKey == nil {
		return localVarReturnValue, nil, reportError("deploymentKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentKey
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsSshKeysDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiV1CatalogDeploymentsSshKeysDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsSshKeysDestroyExecute(r)
}

/*
V1CatalogDeploymentsSshKeysDestroy Method for V1CatalogDeploymentsSshKeysDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsSshKeysDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysDestroy(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsSshKeysDestroyRequest {
	return ApiV1CatalogDeploymentsSshKeysDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysDestroyExecute(r ApiV1CatalogDeploymentsSshKeysDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsSshKeysDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsSshKeysListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           *string
	name         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiV1CatalogDeploymentsSshKeysListRequest) Id(id string) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogDeploymentsSshKeysListRequest) Name(name string) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsSshKeysListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsSshKeysListRequest) Page(page int32) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsSshKeysListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-keys by name
func (r ApiV1CatalogDeploymentsSshKeysListRequest) Search(search string) ApiV1CatalogDeploymentsSshKeysListRequest {
	r.search = &search
	return r
}

func (r ApiV1CatalogDeploymentsSshKeysListRequest) Execute() (*PaginatedDeploymentKeyList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsSshKeysListExecute(r)
}

/*
V1CatalogDeploymentsSshKeysList Method for V1CatalogDeploymentsSshKeysList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsSshKeysListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsSshKeysListRequest {
	return ApiV1CatalogDeploymentsSshKeysListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentKeyList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsSshKeysListExecute(r ApiV1CatalogDeploymentsSshKeysListRequest) (*PaginatedDeploymentKeyList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentKeyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsSshKeysList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsStatsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
}

func (r ApiV1CatalogDeploymentsStatsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsStatsRetrieveExecute(r)
}

/*
V1CatalogDeploymentsStatsRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV1CatalogDeploymentsStatsRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsStatsRetrieve(ctx context.Context) ApiV1CatalogDeploymentsStatsRetrieveRequest {
	return ApiV1CatalogDeploymentsStatsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsStatsRetrieveExecute(r ApiV1CatalogDeploymentsStatsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsStatsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsTasksCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	deploymentTask *DeploymentTask
}

func (r ApiV1CatalogDeploymentsTasksCreateRequest) DeploymentTask(deploymentTask DeploymentTask) ApiV1CatalogDeploymentsTasksCreateRequest {
	r.deploymentTask = &deploymentTask
	return r
}

func (r ApiV1CatalogDeploymentsTasksCreateRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsTasksCreateExecute(r)
}

/*
V1CatalogDeploymentsTasksCreate ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsTasksCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksCreate(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsTasksCreateRequest {
	return ApiV1CatalogDeploymentsTasksCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksCreateExecute(r ApiV1CatalogDeploymentsTasksCreateRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsTasksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentTask == nil {
		return localVarReturnValue, nil, reportError("deploymentTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentTask
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsTasksListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	action       *string
	id           *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
	status       *string
}

// The action the task will perform  * &#x60;start_instances&#x60; - Start all instances in the deployment * &#x60;stop_instances&#x60; - Stop all instances in the deployment
func (r ApiV1CatalogDeploymentsTasksListRequest) Action(action string) ApiV1CatalogDeploymentsTasksListRequest {
	r.action = &action
	return r
}

func (r ApiV1CatalogDeploymentsTasksListRequest) Id(id string) ApiV1CatalogDeploymentsTasksListRequest {
	r.id = &id
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogDeploymentsTasksListRequest) Ordering(ordering string) ApiV1CatalogDeploymentsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogDeploymentsTasksListRequest) Page(page int32) ApiV1CatalogDeploymentsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogDeploymentsTasksListRequest) PageSize(pageSize int32) ApiV1CatalogDeploymentsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-tasks by action, id, status, status_text
func (r ApiV1CatalogDeploymentsTasksListRequest) Search(search string) ApiV1CatalogDeploymentsTasksListRequest {
	r.search = &search
	return r
}

// Current status of the task  * &#x60;completed&#x60; - completed * &#x60;failed&#x60; - failed * &#x60;pending&#x60; - pending * &#x60;processing&#x60; - processing * &#x60;retrying&#x60; - retrying
func (r ApiV1CatalogDeploymentsTasksListRequest) Status(status string) ApiV1CatalogDeploymentsTasksListRequest {
	r.status = &status
	return r
}

func (r ApiV1CatalogDeploymentsTasksListRequest) Execute() (*PaginatedDeploymentTaskList, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsTasksListExecute(r)
}

/*
V1CatalogDeploymentsTasksList ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiV1CatalogDeploymentsTasksListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksList(ctx context.Context, deploymentId string) ApiV1CatalogDeploymentsTasksListRequest {
	return ApiV1CatalogDeploymentsTasksListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentTaskList
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksListExecute(r ApiV1CatalogDeploymentsTasksListRequest) (*PaginatedDeploymentTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsTasksRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiV1CatalogDeploymentsTasksRetrieveRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsTasksRetrieveExecute(r)
}

/*
V1CatalogDeploymentsTasksRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiV1CatalogDeploymentsTasksRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksRetrieve(ctx context.Context, deploymentId string, id string) ApiV1CatalogDeploymentsTasksRetrieveRequest {
	return ApiV1CatalogDeploymentsTasksRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsTasksRetrieveExecute(r ApiV1CatalogDeploymentsTasksRetrieveRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogDeploymentsUpdateRequest struct {
	ctx              context.Context
	ApiService       *CatalogDeploymentsAPIService
	id               string
	deploymentUpdate *DeploymentUpdate
}

func (r ApiV1CatalogDeploymentsUpdateRequest) DeploymentUpdate(deploymentUpdate DeploymentUpdate) ApiV1CatalogDeploymentsUpdateRequest {
	r.deploymentUpdate = &deploymentUpdate
	return r
}

func (r ApiV1CatalogDeploymentsUpdateRequest) Execute() (*DeploymentUpdate, *http.Response, error) {
	return r.ApiService.V1CatalogDeploymentsUpdateExecute(r)
}

/*
V1CatalogDeploymentsUpdate Method for V1CatalogDeploymentsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiV1CatalogDeploymentsUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsUpdate(ctx context.Context, id string) ApiV1CatalogDeploymentsUpdateRequest {
	return ApiV1CatalogDeploymentsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeploymentUpdate
func (a *CatalogDeploymentsAPIService) V1CatalogDeploymentsUpdateExecute(r ApiV1CatalogDeploymentsUpdateRequest) (*DeploymentUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogDeploymentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	experienceNote *ExperienceNote
}

func (r ApiV1CatalogExperiencesNotesCreateRequest) ExperienceNote(experienceNote ExperienceNote) ApiV1CatalogExperiencesNotesCreateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiV1CatalogExperiencesNotesCreateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesCreateExecute(r)
}

/*
V1CatalogExperiencesNotesCreate Method for V1CatalogExperiencesNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@return ApiV1CatalogExperiencesNotesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesCreate(ctx context.Context, experienceId string) ApiV1CatalogExperiencesNotesCreateRequest {
	return ApiV1CatalogExperiencesNotesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesCreateExecute(r ApiV1CatalogExperiencesNotesCreateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	id           string
}

func (r ApiV1CatalogExperiencesNotesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesDestroyExecute(r)
}

/*
V1CatalogExperiencesNotesDestroy Method for V1CatalogExperiencesNotesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiV1CatalogExperiencesNotesDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesDestroy(ctx context.Context, experienceId string, id string) ApiV1CatalogExperiencesNotesDestroyRequest {
	return ApiV1CatalogExperiencesNotesDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesDestroyExecute(r ApiV1CatalogExperiencesNotesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	createdBy    *int32
	experience   *string
	fields       *string
	id           *string
	modifiedBy   *int32
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiV1CatalogExperiencesNotesListRequest) CreatedBy(createdBy int32) ApiV1CatalogExperiencesNotesListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiV1CatalogExperiencesNotesListRequest) Experience(experience string) ApiV1CatalogExperiencesNotesListRequest {
	r.experience = &experience
	return r
}

// Include only the specified fields in the response
func (r ApiV1CatalogExperiencesNotesListRequest) Fields(fields string) ApiV1CatalogExperiencesNotesListRequest {
	r.fields = &fields
	return r
}

func (r ApiV1CatalogExperiencesNotesListRequest) Id(id string) ApiV1CatalogExperiencesNotesListRequest {
	r.id = &id
	return r
}

func (r ApiV1CatalogExperiencesNotesListRequest) ModifiedBy(modifiedBy int32) ApiV1CatalogExperiencesNotesListRequest {
	r.modifiedBy = &modifiedBy
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogExperiencesNotesListRequest) Omit(omit string) ApiV1CatalogExperiencesNotesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiV1CatalogExperiencesNotesListRequest) Ordering(ordering string) ApiV1CatalogExperiencesNotesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiV1CatalogExperiencesNotesListRequest) Page(page int32) ApiV1CatalogExperiencesNotesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiV1CatalogExperiencesNotesListRequest) PageSize(pageSize int32) ApiV1CatalogExperiencesNotesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for experience-notes by content
func (r ApiV1CatalogExperiencesNotesListRequest) Search(search string) ApiV1CatalogExperiencesNotesListRequest {
	r.search = &search
	return r
}

func (r ApiV1CatalogExperiencesNotesListRequest) Execute() (*PaginatedExperienceNoteList, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesListExecute(r)
}

/*
V1CatalogExperiencesNotesList Method for V1CatalogExperiencesNotesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@return ApiV1CatalogExperiencesNotesListRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesList(ctx context.Context, experienceId string) ApiV1CatalogExperiencesNotesListRequest {
	return ApiV1CatalogExperiencesNotesListRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
	}
}

// Execute executes the request
//
//	@return PaginatedExperienceNoteList
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesListExecute(r ApiV1CatalogExperiencesNotesListRequest) (*PaginatedExperienceNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedExperienceNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.modifiedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by", r.modifiedBy, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	id             string
	experienceNote *ExperienceNote
}

func (r ApiV1CatalogExperiencesNotesPartialUpdateRequest) ExperienceNote(experienceNote ExperienceNote) ApiV1CatalogExperiencesNotesPartialUpdateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiV1CatalogExperiencesNotesPartialUpdateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesPartialUpdateExecute(r)
}

/*
V1CatalogExperiencesNotesPartialUpdate Method for V1CatalogExperiencesNotesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiV1CatalogExperiencesNotesPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesPartialUpdate(ctx context.Context, experienceId string, id string) ApiV1CatalogExperiencesNotesPartialUpdateRequest {
	return ApiV1CatalogExperiencesNotesPartialUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesPartialUpdateExecute(r ApiV1CatalogExperiencesNotesPartialUpdateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	id           string
	fields       *string
	omit         *string
}

// Include only the specified fields in the response
func (r ApiV1CatalogExperiencesNotesRetrieveRequest) Fields(fields string) ApiV1CatalogExperiencesNotesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiV1CatalogExperiencesNotesRetrieveRequest) Omit(omit string) ApiV1CatalogExperiencesNotesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiV1CatalogExperiencesNotesRetrieveRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesRetrieveExecute(r)
}

/*
V1CatalogExperiencesNotesRetrieve Method for V1CatalogExperiencesNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiV1CatalogExperiencesNotesRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesRetrieve(ctx context.Context, experienceId string, id string) ApiV1CatalogExperiencesNotesRetrieveRequest {
	return ApiV1CatalogExperiencesNotesRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesRetrieveExecute(r ApiV1CatalogExperiencesNotesRetrieveRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CatalogExperiencesNotesUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	id             string
	experienceNote *ExperienceNote
}

func (r ApiV1CatalogExperiencesNotesUpdateRequest) ExperienceNote(experienceNote ExperienceNote) ApiV1CatalogExperiencesNotesUpdateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiV1CatalogExperiencesNotesUpdateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.V1CatalogExperiencesNotesUpdateExecute(r)
}

/*
V1CatalogExperiencesNotesUpdate Method for V1CatalogExperiencesNotesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiV1CatalogExperiencesNotesUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesUpdate(ctx context.Context, experienceId string, id string) ApiV1CatalogExperiencesNotesUpdateRequest {
	return ApiV1CatalogExperiencesNotesUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) V1CatalogExperiencesNotesUpdateExecute(r ApiV1CatalogExperiencesNotesUpdateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.V1CatalogExperiencesNotesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
