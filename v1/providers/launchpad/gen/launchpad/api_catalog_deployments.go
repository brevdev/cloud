/*
NVIDIA LaunchPad API

RESTful API for interacting with the NVIDIA LaunchPad platform

API version: 2.36.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CatalogDeploymentsAPIService CatalogDeploymentsAPI service
type CatalogDeploymentsAPIService service

type ApiCatalogDeploymentsBulkPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *CatalogDeploymentsAPIService
	deploymentBulkUpdate *DeploymentBulkUpdate
}

func (r ApiCatalogDeploymentsBulkPartialUpdateRequest) DeploymentBulkUpdate(deploymentBulkUpdate DeploymentBulkUpdate) ApiCatalogDeploymentsBulkPartialUpdateRequest {
	r.deploymentBulkUpdate = &deploymentBulkUpdate
	return r
}

func (r ApiCatalogDeploymentsBulkPartialUpdateRequest) Execute() (*DeploymentBulkUpdate, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsBulkPartialUpdateExecute(r)
}

/*
CatalogDeploymentsBulkPartialUpdate Method for CatalogDeploymentsBulkPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogDeploymentsBulkPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsBulkPartialUpdate(ctx context.Context) ApiCatalogDeploymentsBulkPartialUpdateRequest {
	return ApiCatalogDeploymentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeploymentBulkUpdate
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsBulkPartialUpdateExecute(r ApiCatalogDeploymentsBulkPartialUpdateRequest) (*DeploymentBulkUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentBulkUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/bulk/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentBulkUpdate == nil {
		return localVarReturnValue, nil, reportError("deploymentBulkUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentBulkUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsCreateRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	deployment *Deployment
	expand     *string
}

func (r ApiCatalogDeploymentsCreateRequest) Deployment(deployment Deployment) ApiCatalogDeploymentsCreateRequest {
	r.deployment = &deployment
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiCatalogDeploymentsCreateRequest) Expand(expand string) ApiCatalogDeploymentsCreateRequest {
	r.expand = &expand
	return r
}

func (r ApiCatalogDeploymentsCreateRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsCreateExecute(r)
}

/*
CatalogDeploymentsCreate Method for CatalogDeploymentsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogDeploymentsCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsCreate(ctx context.Context) ApiCatalogDeploymentsCreateRequest {
	return ApiCatalogDeploymentsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Deployment
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsCreateExecute(r ApiCatalogDeploymentsCreateRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deployment == nil {
		return localVarReturnValue, nil, reportError("deployment is required and must be specified")
	}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deployment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsDestroyRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
}

func (r ApiCatalogDeploymentsDestroyRequest) Execute() (*DocDeploymentDelete, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsDestroyExecute(r)
}

/*
CatalogDeploymentsDestroy Method for CatalogDeploymentsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiCatalogDeploymentsDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsDestroy(ctx context.Context, id string) ApiCatalogDeploymentsDestroyRequest {
	return ApiCatalogDeploymentsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DocDeploymentDelete
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsDestroyExecute(r ApiCatalogDeploymentsDestroyRequest) (*DocDeploymentDelete, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DocDeploymentDelete
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsDestroy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsHistoryListRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
	page       *int32
	pageSize   *int32
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsHistoryListRequest) Page(page int32) ApiCatalogDeploymentsHistoryListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsHistoryListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsHistoryListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCatalogDeploymentsHistoryListRequest) Execute() (*PaginatedModelChangeList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsHistoryListExecute(r)
}

/*
CatalogDeploymentsHistoryList Method for CatalogDeploymentsHistoryList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCatalogDeploymentsHistoryListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsHistoryList(ctx context.Context, id string) ApiCatalogDeploymentsHistoryListRequest {
	return ApiCatalogDeploymentsHistoryListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PaginatedModelChangeList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsHistoryListExecute(r ApiCatalogDeploymentsHistoryListRequest) (*PaginatedModelChangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedModelChangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsInstancesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	fields       *string
	id           *string
	instanceId   *string
	name         *string
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
	state        *string
}

// Include only the specified fields in the response
func (r ApiCatalogDeploymentsInstancesListRequest) Fields(fields string) ApiCatalogDeploymentsInstancesListRequest {
	r.fields = &fields
	return r
}

func (r ApiCatalogDeploymentsInstancesListRequest) Id(id string) ApiCatalogDeploymentsInstancesListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogDeploymentsInstancesListRequest) InstanceId(instanceId string) ApiCatalogDeploymentsInstancesListRequest {
	r.instanceId = &instanceId
	return r
}

func (r ApiCatalogDeploymentsInstancesListRequest) Name(name string) ApiCatalogDeploymentsInstancesListRequest {
	r.name = &name
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogDeploymentsInstancesListRequest) Omit(omit string) ApiCatalogDeploymentsInstancesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsInstancesListRequest) Ordering(ordering string) ApiCatalogDeploymentsInstancesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsInstancesListRequest) Page(page int32) ApiCatalogDeploymentsInstancesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsInstancesListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsInstancesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-instances by id, instance_id, name, state, tags
func (r ApiCatalogDeploymentsInstancesListRequest) Search(search string) ApiCatalogDeploymentsInstancesListRequest {
	r.search = &search
	return r
}

// Current lifecycle state of this instance  * &#x60;running&#x60; - Instance is running * &#x60;starting&#x60; - Instance is starting * &#x60;stopped&#x60; - Instance is stopped * &#x60;stopping&#x60; - Instance is stopping * &#x60;unknown&#x60; - Instance state is currently unknown
func (r ApiCatalogDeploymentsInstancesListRequest) State(state string) ApiCatalogDeploymentsInstancesListRequest {
	r.state = &state
	return r
}

func (r ApiCatalogDeploymentsInstancesListRequest) Execute() (*PaginatedDeploymentInstanceList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsInstancesListExecute(r)
}

/*
CatalogDeploymentsInstancesList ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsInstancesListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsInstancesList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsInstancesListRequest {
	return ApiCatalogDeploymentsInstancesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentInstanceList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsInstancesListExecute(r ApiCatalogDeploymentsInstancesListRequest) (*PaginatedDeploymentInstanceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentInstanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsInstancesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/instances/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsListRequest struct {
	ctx                    context.Context
	ApiService             *CatalogDeploymentsAPIService
	bastionOperatingSystem *string
	cluster                *string
	clusterGpusModel       *[]string
	collectionBranch       *string
	expand                 *string
	experience             *string
	experienceBranch       *string
	expired                *bool
	expiresAt              *string
	expiring               *string
	fields                 *string
	flightcontrolRelease   *string
	garageId               *string
	gcBranch               *string
	gpuAlias               *string
	gpuCount               *int32
	gpuModel               *string
	gpuOsName              *string
	gpuOsRelease           *string
	gpuOsVersion           *string
	id                     *string
	nodeCount              *int32
	oemName                *string
	omit                   *string
	ordering               *string
	orgName                *string
	page                   *int32
	pageSize               *int32
	persistOnFailure       *bool
	persona                *string
	pipeline               *int32
	pipelineBranch         *string
	platform               *string
	priority               *string
	providerName           *string
	region                 *string
	requestId              *string
	requesterEmail         *string
	requesterName          *string
	salesId                *string
	salesOwnerEmail        *string
	salesOwnerName         *string
	search                 *string
	state                  *[]string
	workshop               *bool
	workshopId             *string
}

func (r ApiCatalogDeploymentsListRequest) BastionOperatingSystem(bastionOperatingSystem string) ApiCatalogDeploymentsListRequest {
	r.bastionOperatingSystem = &bastionOperatingSystem
	return r
}

func (r ApiCatalogDeploymentsListRequest) Cluster(cluster string) ApiCatalogDeploymentsListRequest {
	r.cluster = &cluster
	return r
}

// Multiple values may be separated by commas.
func (r ApiCatalogDeploymentsListRequest) ClusterGpusModel(clusterGpusModel []string) ApiCatalogDeploymentsListRequest {
	r.clusterGpusModel = &clusterGpusModel
	return r
}

func (r ApiCatalogDeploymentsListRequest) CollectionBranch(collectionBranch string) ApiCatalogDeploymentsListRequest {
	r.collectionBranch = &collectionBranch
	return r
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiCatalogDeploymentsListRequest) Expand(expand string) ApiCatalogDeploymentsListRequest {
	r.expand = &expand
	return r
}

func (r ApiCatalogDeploymentsListRequest) Experience(experience string) ApiCatalogDeploymentsListRequest {
	r.experience = &experience
	return r
}

func (r ApiCatalogDeploymentsListRequest) ExperienceBranch(experienceBranch string) ApiCatalogDeploymentsListRequest {
	r.experienceBranch = &experienceBranch
	return r
}

func (r ApiCatalogDeploymentsListRequest) Expired(expired bool) ApiCatalogDeploymentsListRequest {
	r.expired = &expired
	return r
}

func (r ApiCatalogDeploymentsListRequest) ExpiresAt(expiresAt string) ApiCatalogDeploymentsListRequest {
	r.expiresAt = &expiresAt
	return r
}

// Include deployments whose expires_at value is within the given range (inclusive), specified as \&quot;today\&quot;, \&quot;tomorrow\&quot;, or \&quot;{start}[,end]\&quot;. Start and end times must be in ISO format.
func (r ApiCatalogDeploymentsListRequest) Expiring(expiring string) ApiCatalogDeploymentsListRequest {
	r.expiring = &expiring
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogDeploymentsListRequest) Fields(fields string) ApiCatalogDeploymentsListRequest {
	r.fields = &fields
	return r
}

func (r ApiCatalogDeploymentsListRequest) FlightcontrolRelease(flightcontrolRelease string) ApiCatalogDeploymentsListRequest {
	r.flightcontrolRelease = &flightcontrolRelease
	return r
}

func (r ApiCatalogDeploymentsListRequest) GarageId(garageId string) ApiCatalogDeploymentsListRequest {
	r.garageId = &garageId
	return r
}

func (r ApiCatalogDeploymentsListRequest) GcBranch(gcBranch string) ApiCatalogDeploymentsListRequest {
	r.gcBranch = &gcBranch
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuAlias(gpuAlias string) ApiCatalogDeploymentsListRequest {
	r.gpuAlias = &gpuAlias
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuCount(gpuCount int32) ApiCatalogDeploymentsListRequest {
	r.gpuCount = &gpuCount
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuModel(gpuModel string) ApiCatalogDeploymentsListRequest {
	r.gpuModel = &gpuModel
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuOsName(gpuOsName string) ApiCatalogDeploymentsListRequest {
	r.gpuOsName = &gpuOsName
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuOsRelease(gpuOsRelease string) ApiCatalogDeploymentsListRequest {
	r.gpuOsRelease = &gpuOsRelease
	return r
}

func (r ApiCatalogDeploymentsListRequest) GpuOsVersion(gpuOsVersion string) ApiCatalogDeploymentsListRequest {
	r.gpuOsVersion = &gpuOsVersion
	return r
}

func (r ApiCatalogDeploymentsListRequest) Id(id string) ApiCatalogDeploymentsListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogDeploymentsListRequest) NodeCount(nodeCount int32) ApiCatalogDeploymentsListRequest {
	r.nodeCount = &nodeCount
	return r
}

func (r ApiCatalogDeploymentsListRequest) OemName(oemName string) ApiCatalogDeploymentsListRequest {
	r.oemName = &oemName
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogDeploymentsListRequest) Omit(omit string) ApiCatalogDeploymentsListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsListRequest) Ordering(ordering string) ApiCatalogDeploymentsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiCatalogDeploymentsListRequest) OrgName(orgName string) ApiCatalogDeploymentsListRequest {
	r.orgName = &orgName
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsListRequest) Page(page int32) ApiCatalogDeploymentsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCatalogDeploymentsListRequest) PersistOnFailure(persistOnFailure bool) ApiCatalogDeploymentsListRequest {
	r.persistOnFailure = &persistOnFailure
	return r
}

func (r ApiCatalogDeploymentsListRequest) Persona(persona string) ApiCatalogDeploymentsListRequest {
	r.persona = &persona
	return r
}

func (r ApiCatalogDeploymentsListRequest) Pipeline(pipeline int32) ApiCatalogDeploymentsListRequest {
	r.pipeline = &pipeline
	return r
}

func (r ApiCatalogDeploymentsListRequest) PipelineBranch(pipelineBranch string) ApiCatalogDeploymentsListRequest {
	r.pipelineBranch = &pipelineBranch
	return r
}

// Override the default platform selection  * &#x60;air&#x60; - NVIDIA Air * &#x60;flight_deck&#x60; - Flight Deck * &#x60;kvm_bastion&#x60; - KVM Bastion * &#x60;lp-vmware-platform&#x60; - lp-vmware-platform * &#x60;minimal&#x60; - minimal * &#x60;openshift&#x60; - OpenShift * &#x60;vsphere&#x60; - vSphere * &#x60;vsphere_horizon&#x60; - VMware Horizon * &#x60;vsphere7&#x60; - vSphere 7 * &#x60;vsphere8&#x60; - vSphere 8
func (r ApiCatalogDeploymentsListRequest) Platform(platform string) ApiCatalogDeploymentsListRequest {
	r.platform = &platform
	return r
}

// Priority level for the request  * &#x60;p0&#x60; - p0 * &#x60;p1&#x60; - p1 * &#x60;p2&#x60; - p2 * &#x60;p3&#x60; - p3
func (r ApiCatalogDeploymentsListRequest) Priority(priority string) ApiCatalogDeploymentsListRequest {
	r.priority = &priority
	return r
}

func (r ApiCatalogDeploymentsListRequest) ProviderName(providerName string) ApiCatalogDeploymentsListRequest {
	r.providerName = &providerName
	return r
}

func (r ApiCatalogDeploymentsListRequest) Region(region string) ApiCatalogDeploymentsListRequest {
	r.region = &region
	return r
}

func (r ApiCatalogDeploymentsListRequest) RequestId(requestId string) ApiCatalogDeploymentsListRequest {
	r.requestId = &requestId
	return r
}

func (r ApiCatalogDeploymentsListRequest) RequesterEmail(requesterEmail string) ApiCatalogDeploymentsListRequest {
	r.requesterEmail = &requesterEmail
	return r
}

func (r ApiCatalogDeploymentsListRequest) RequesterName(requesterName string) ApiCatalogDeploymentsListRequest {
	r.requesterName = &requesterName
	return r
}

func (r ApiCatalogDeploymentsListRequest) SalesId(salesId string) ApiCatalogDeploymentsListRequest {
	r.salesId = &salesId
	return r
}

func (r ApiCatalogDeploymentsListRequest) SalesOwnerEmail(salesOwnerEmail string) ApiCatalogDeploymentsListRequest {
	r.salesOwnerEmail = &salesOwnerEmail
	return r
}

func (r ApiCatalogDeploymentsListRequest) SalesOwnerName(salesOwnerName string) ApiCatalogDeploymentsListRequest {
	r.salesOwnerName = &salesOwnerName
	return r
}

// Search for deployments by bastion_operating_system, collection_branch, experience_branch, experience catalog_id, experience catalog_id_alias, experience id, experience title, expires_at, flightcontrol_release, garage_id, gc_branch, gpu_alias, gpu_model, gpu_os_name, gpu_os_release, gpu_os_version, id, oem_name, org_name, persona, pipeline_branch, platform, provider_name, region, request_id, requester_email, requester_name, sales_id, sales_owner_email, sales_owner_name, services url, state, tags, workshop_id
func (r ApiCatalogDeploymentsListRequest) Search(search string) ApiCatalogDeploymentsListRequest {
	r.search = &search
	return r
}

// Multiple values may be separated by commas.  * &#x60;destroyed&#x60; - Deployment has been fully destroyed * &#x60;destroying&#x60; - Deployment is being destroyed * &#x60;error&#x60; - Deployment has encountered a fatal error and will not be retried * &#x60;failed&#x60; - Deployment has failed but may be retried * &#x60;paused&#x60; - Deployment is paused but may be retried later * &#x60;ready&#x60; - Deployment is ready and all instances are running * &#x60;retrying&#x60; - Deployment is retrying * &#x60;starting&#x60; - Deployment instances are starting * &#x60;stopped&#x60; - Deployment instances are stopped * &#x60;stopping&#x60; - Deployment instances are stopping * &#x60;waiting&#x60; - Waiting for deployment to be ready
func (r ApiCatalogDeploymentsListRequest) State(state []string) ApiCatalogDeploymentsListRequest {
	r.state = &state
	return r
}

func (r ApiCatalogDeploymentsListRequest) Workshop(workshop bool) ApiCatalogDeploymentsListRequest {
	r.workshop = &workshop
	return r
}

func (r ApiCatalogDeploymentsListRequest) WorkshopId(workshopId string) ApiCatalogDeploymentsListRequest {
	r.workshopId = &workshopId
	return r
}

func (r ApiCatalogDeploymentsListRequest) Execute() (*PaginatedDeploymentList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsListExecute(r)
}

/*
CatalogDeploymentsList Method for CatalogDeploymentsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogDeploymentsListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsList(ctx context.Context) ApiCatalogDeploymentsListRequest {
	return ApiCatalogDeploymentsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsListExecute(r ApiCatalogDeploymentsListRequest) (*PaginatedDeploymentList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bastionOperatingSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bastion_operating_system", r.bastionOperatingSystem, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.clusterGpusModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_gpus_model", r.clusterGpusModel, "form", "csv")
	}
	if r.collectionBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection_branch", r.collectionBranch, "form", "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.experienceBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience_branch", r.experienceBranch, "form", "")
	}
	if r.expired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expired", r.expired, "form", "")
	}
	if r.expiresAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires_at", r.expiresAt, "form", "")
	}
	if r.expiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiring", r.expiring, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.flightcontrolRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flightcontrol_release", r.flightcontrolRelease, "form", "")
	}
	if r.garageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "garage_id", r.garageId, "form", "")
	}
	if r.gcBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gc_branch", r.gcBranch, "form", "")
	}
	if r.gpuAlias != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_alias", r.gpuAlias, "form", "")
	}
	if r.gpuCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_count", r.gpuCount, "form", "")
	}
	if r.gpuModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_model", r.gpuModel, "form", "")
	}
	if r.gpuOsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_name", r.gpuOsName, "form", "")
	}
	if r.gpuOsRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_release", r.gpuOsRelease, "form", "")
	}
	if r.gpuOsVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpu_os_version", r.gpuOsVersion, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.nodeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_count", r.nodeCount, "form", "")
	}
	if r.oemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oem_name", r.oemName, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.orgName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "org_name", r.orgName, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.persistOnFailure != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persist_on_failure", r.persistOnFailure, "form", "")
	}
	if r.persona != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "persona", r.persona, "form", "")
	}
	if r.pipeline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline", r.pipeline, "form", "")
	}
	if r.pipelineBranch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline_branch", r.pipelineBranch, "form", "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "form", "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "form", "")
	}
	if r.providerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider_name", r.providerName, "form", "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "form", "")
	}
	if r.requesterEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester_email", r.requesterEmail, "form", "")
	}
	if r.requesterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester_name", r.requesterName, "form", "")
	}
	if r.salesId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_id", r.salesId, "form", "")
	}
	if r.salesOwnerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_owner_email", r.salesOwnerEmail, "form", "")
	}
	if r.salesOwnerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sales_owner_name", r.salesOwnerName, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.workshop != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workshop", r.workshop, "form", "")
	}
	if r.workshopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workshop_id", r.workshopId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	deploymentNote *DeploymentNote
}

func (r ApiCatalogDeploymentsNotesCreateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiCatalogDeploymentsNotesCreateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiCatalogDeploymentsNotesCreateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesCreateExecute(r)
}

/*
CatalogDeploymentsNotesCreate Method for CatalogDeploymentsNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsNotesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesCreate(ctx context.Context, deploymentId string) ApiCatalogDeploymentsNotesCreateRequest {
	return ApiCatalogDeploymentsNotesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesCreateExecute(r ApiCatalogDeploymentsNotesCreateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiCatalogDeploymentsNotesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesDestroyExecute(r)
}

/*
CatalogDeploymentsNotesDestroy Method for CatalogDeploymentsNotesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsNotesDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesDestroy(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsNotesDestroyRequest {
	return ApiCatalogDeploymentsNotesDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesDestroyExecute(r ApiCatalogDeploymentsNotesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	createdBy    *int32
	deployment   *string
	fields       *string
	id           *string
	modifiedBy   *int32
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiCatalogDeploymentsNotesListRequest) CreatedBy(createdBy int32) ApiCatalogDeploymentsNotesListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiCatalogDeploymentsNotesListRequest) Deployment(deployment string) ApiCatalogDeploymentsNotesListRequest {
	r.deployment = &deployment
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogDeploymentsNotesListRequest) Fields(fields string) ApiCatalogDeploymentsNotesListRequest {
	r.fields = &fields
	return r
}

func (r ApiCatalogDeploymentsNotesListRequest) Id(id string) ApiCatalogDeploymentsNotesListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogDeploymentsNotesListRequest) ModifiedBy(modifiedBy int32) ApiCatalogDeploymentsNotesListRequest {
	r.modifiedBy = &modifiedBy
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogDeploymentsNotesListRequest) Omit(omit string) ApiCatalogDeploymentsNotesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsNotesListRequest) Ordering(ordering string) ApiCatalogDeploymentsNotesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsNotesListRequest) Page(page int32) ApiCatalogDeploymentsNotesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsNotesListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsNotesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-notes by content
func (r ApiCatalogDeploymentsNotesListRequest) Search(search string) ApiCatalogDeploymentsNotesListRequest {
	r.search = &search
	return r
}

func (r ApiCatalogDeploymentsNotesListRequest) Execute() (*PaginatedDeploymentNoteList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesListExecute(r)
}

/*
CatalogDeploymentsNotesList Method for CatalogDeploymentsNotesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsNotesListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsNotesListRequest {
	return ApiCatalogDeploymentsNotesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentNoteList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesListExecute(r ApiCatalogDeploymentsNotesListRequest) (*PaginatedDeploymentNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.deployment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployment", r.deployment, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.modifiedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by", r.modifiedBy, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	id             string
	deploymentNote *DeploymentNote
}

func (r ApiCatalogDeploymentsNotesPartialUpdateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiCatalogDeploymentsNotesPartialUpdateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiCatalogDeploymentsNotesPartialUpdateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesPartialUpdateExecute(r)
}

/*
CatalogDeploymentsNotesPartialUpdate Method for CatalogDeploymentsNotesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsNotesPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesPartialUpdate(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsNotesPartialUpdateRequest {
	return ApiCatalogDeploymentsNotesPartialUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesPartialUpdateExecute(r ApiCatalogDeploymentsNotesPartialUpdateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
	fields       *string
	omit         *string
}

// Include only the specified fields in the response
func (r ApiCatalogDeploymentsNotesRetrieveRequest) Fields(fields string) ApiCatalogDeploymentsNotesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogDeploymentsNotesRetrieveRequest) Omit(omit string) ApiCatalogDeploymentsNotesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiCatalogDeploymentsNotesRetrieveRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesRetrieveExecute(r)
}

/*
CatalogDeploymentsNotesRetrieve Method for CatalogDeploymentsNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsNotesRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesRetrieve(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsNotesRetrieveRequest {
	return ApiCatalogDeploymentsNotesRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesRetrieveExecute(r ApiCatalogDeploymentsNotesRetrieveRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsNotesUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	id             string
	deploymentNote *DeploymentNote
}

func (r ApiCatalogDeploymentsNotesUpdateRequest) DeploymentNote(deploymentNote DeploymentNote) ApiCatalogDeploymentsNotesUpdateRequest {
	r.deploymentNote = &deploymentNote
	return r
}

func (r ApiCatalogDeploymentsNotesUpdateRequest) Execute() (*DeploymentNote, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsNotesUpdateExecute(r)
}

/*
CatalogDeploymentsNotesUpdate Method for CatalogDeploymentsNotesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsNotesUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesUpdate(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsNotesUpdateRequest {
	return ApiCatalogDeploymentsNotesUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentNote
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsNotesUpdateExecute(r ApiCatalogDeploymentsNotesUpdateRequest) (*DeploymentNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsNotesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentNote == nil {
		return localVarReturnValue, nil, reportError("deploymentNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *CatalogDeploymentsAPIService
	id               string
	deploymentUpdate *DeploymentUpdate
}

func (r ApiCatalogDeploymentsPartialUpdateRequest) DeploymentUpdate(deploymentUpdate DeploymentUpdate) ApiCatalogDeploymentsPartialUpdateRequest {
	r.deploymentUpdate = &deploymentUpdate
	return r
}

func (r ApiCatalogDeploymentsPartialUpdateRequest) Execute() (*DeploymentUpdate, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsPartialUpdateExecute(r)
}

/*
CatalogDeploymentsPartialUpdate Method for CatalogDeploymentsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiCatalogDeploymentsPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPartialUpdate(ctx context.Context, id string) ApiCatalogDeploymentsPartialUpdateRequest {
	return ApiCatalogDeploymentsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeploymentUpdate
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPartialUpdateExecute(r ApiCatalogDeploymentsPartialUpdateRequest) (*DeploymentUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsPipelinesCreateRequest struct {
	ctx                context.Context
	ApiService         *CatalogDeploymentsAPIService
	deploymentId       string
	deploymentPipeline *DeploymentPipeline
}

func (r ApiCatalogDeploymentsPipelinesCreateRequest) DeploymentPipeline(deploymentPipeline DeploymentPipeline) ApiCatalogDeploymentsPipelinesCreateRequest {
	r.deploymentPipeline = &deploymentPipeline
	return r
}

func (r ApiCatalogDeploymentsPipelinesCreateRequest) Execute() (*DeploymentPipeline, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsPipelinesCreateExecute(r)
}

/*
CatalogDeploymentsPipelinesCreate Method for CatalogDeploymentsPipelinesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsPipelinesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPipelinesCreate(ctx context.Context, deploymentId string) ApiCatalogDeploymentsPipelinesCreateRequest {
	return ApiCatalogDeploymentsPipelinesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentPipeline
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPipelinesCreateExecute(r ApiCatalogDeploymentsPipelinesCreateRequest) (*DeploymentPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsPipelinesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentPipeline == nil {
		return localVarReturnValue, nil, reportError("deploymentPipeline is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentPipeline
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsPipelinesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	action       *string
	id           *string
	ordering     *string
	page         *int32
	pageSize     *int32
	pipelineId   *int32
	search       *string
}

// Action for the pipeline to run  * &#x60;apply&#x60; - apply * &#x60;destroy&#x60; - destroy
func (r ApiCatalogDeploymentsPipelinesListRequest) Action(action string) ApiCatalogDeploymentsPipelinesListRequest {
	r.action = &action
	return r
}

func (r ApiCatalogDeploymentsPipelinesListRequest) Id(id string) ApiCatalogDeploymentsPipelinesListRequest {
	r.id = &id
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsPipelinesListRequest) Ordering(ordering string) ApiCatalogDeploymentsPipelinesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsPipelinesListRequest) Page(page int32) ApiCatalogDeploymentsPipelinesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsPipelinesListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsPipelinesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCatalogDeploymentsPipelinesListRequest) PipelineId(pipelineId int32) ApiCatalogDeploymentsPipelinesListRequest {
	r.pipelineId = &pipelineId
	return r
}

// Search for deployment-pipelines by action, id, pipeline_id, url
func (r ApiCatalogDeploymentsPipelinesListRequest) Search(search string) ApiCatalogDeploymentsPipelinesListRequest {
	r.search = &search
	return r
}

func (r ApiCatalogDeploymentsPipelinesListRequest) Execute() (*PaginatedDeploymentPipelineList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsPipelinesListExecute(r)
}

/*
CatalogDeploymentsPipelinesList Method for CatalogDeploymentsPipelinesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsPipelinesListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPipelinesList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsPipelinesListRequest {
	return ApiCatalogDeploymentsPipelinesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentPipelineList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsPipelinesListExecute(r ApiCatalogDeploymentsPipelinesListRequest) (*PaginatedDeploymentPipelineList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentPipelineList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsPipelinesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pipelineId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pipeline_id", r.pipelineId, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
	id         string
	expand     *string
	expiring   *string
	fields     *string
	omit       *string
}

// Expand related field(s) instead of only showing a UUID (ex: \&quot;cluster\&quot;).
func (r ApiCatalogDeploymentsRetrieveRequest) Expand(expand string) ApiCatalogDeploymentsRetrieveRequest {
	r.expand = &expand
	return r
}

// Include deployments whose expires_at value is within the given range (inclusive), specified as \&quot;today\&quot;, \&quot;tomorrow\&quot;, or \&quot;{start}[,end]\&quot;. Start and end times must be in ISO format.
func (r ApiCatalogDeploymentsRetrieveRequest) Expiring(expiring string) ApiCatalogDeploymentsRetrieveRequest {
	r.expiring = &expiring
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogDeploymentsRetrieveRequest) Fields(fields string) ApiCatalogDeploymentsRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogDeploymentsRetrieveRequest) Omit(omit string) ApiCatalogDeploymentsRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiCatalogDeploymentsRetrieveRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsRetrieveExecute(r)
}

/*
CatalogDeploymentsRetrieve Method for CatalogDeploymentsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiCatalogDeploymentsRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsRetrieve(ctx context.Context, id string) ApiCatalogDeploymentsRetrieveRequest {
	return ApiCatalogDeploymentsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Deployment
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsRetrieveExecute(r ApiCatalogDeploymentsRetrieveRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	if r.expiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiring", r.expiring, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsServicesCreateRequest struct {
	ctx               context.Context
	ApiService        *CatalogDeploymentsAPIService
	deploymentId      string
	deploymentService *DeploymentService
}

func (r ApiCatalogDeploymentsServicesCreateRequest) DeploymentService(deploymentService DeploymentService) ApiCatalogDeploymentsServicesCreateRequest {
	r.deploymentService = &deploymentService
	return r
}

func (r ApiCatalogDeploymentsServicesCreateRequest) Execute() (*DeploymentService, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsServicesCreateExecute(r)
}

/*
CatalogDeploymentsServicesCreate Method for CatalogDeploymentsServicesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsServicesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsServicesCreate(ctx context.Context, deploymentId string) ApiCatalogDeploymentsServicesCreateRequest {
	return ApiCatalogDeploymentsServicesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentService
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsServicesCreateExecute(r ApiCatalogDeploymentsServicesCreateRequest) (*DeploymentService, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/services/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentService == nil {
		return localVarReturnValue, nil, reportError("deploymentService is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsServicesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           *string
	name         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiCatalogDeploymentsServicesListRequest) Id(id string) ApiCatalogDeploymentsServicesListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogDeploymentsServicesListRequest) Name(name string) ApiCatalogDeploymentsServicesListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsServicesListRequest) Ordering(ordering string) ApiCatalogDeploymentsServicesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsServicesListRequest) Page(page int32) ApiCatalogDeploymentsServicesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsServicesListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsServicesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-services by id, name, url
func (r ApiCatalogDeploymentsServicesListRequest) Search(search string) ApiCatalogDeploymentsServicesListRequest {
	r.search = &search
	return r
}

func (r ApiCatalogDeploymentsServicesListRequest) Execute() (*PaginatedDeploymentServiceList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsServicesListExecute(r)
}

/*
CatalogDeploymentsServicesList Method for CatalogDeploymentsServicesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsServicesListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsServicesList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsServicesListRequest {
	return ApiCatalogDeploymentsServicesListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentServiceList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsServicesListExecute(r ApiCatalogDeploymentsServicesListRequest) (*PaginatedDeploymentServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/services/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsSshKeysCreateRequest struct {
	ctx           context.Context
	ApiService    *CatalogDeploymentsAPIService
	deploymentId  string
	deploymentKey *DeploymentKey
}

func (r ApiCatalogDeploymentsSshKeysCreateRequest) DeploymentKey(deploymentKey DeploymentKey) ApiCatalogDeploymentsSshKeysCreateRequest {
	r.deploymentKey = &deploymentKey
	return r
}

func (r ApiCatalogDeploymentsSshKeysCreateRequest) Execute() (*DeploymentKey, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsSshKeysCreateExecute(r)
}

/*
CatalogDeploymentsSshKeysCreate Method for CatalogDeploymentsSshKeysCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsSshKeysCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysCreate(ctx context.Context, deploymentId string) ApiCatalogDeploymentsSshKeysCreateRequest {
	return ApiCatalogDeploymentsSshKeysCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentKey
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysCreateExecute(r ApiCatalogDeploymentsSshKeysCreateRequest) (*DeploymentKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsSshKeysCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentKey == nil {
		return localVarReturnValue, nil, reportError("deploymentKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentKey
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsSshKeysDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiCatalogDeploymentsSshKeysDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogDeploymentsSshKeysDestroyExecute(r)
}

/*
CatalogDeploymentsSshKeysDestroy Method for CatalogDeploymentsSshKeysDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsSshKeysDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysDestroy(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsSshKeysDestroyRequest {
	return ApiCatalogDeploymentsSshKeysDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysDestroyExecute(r ApiCatalogDeploymentsSshKeysDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsSshKeysDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsSshKeysListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           *string
	name         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiCatalogDeploymentsSshKeysListRequest) Id(id string) ApiCatalogDeploymentsSshKeysListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogDeploymentsSshKeysListRequest) Name(name string) ApiCatalogDeploymentsSshKeysListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsSshKeysListRequest) Ordering(ordering string) ApiCatalogDeploymentsSshKeysListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsSshKeysListRequest) Page(page int32) ApiCatalogDeploymentsSshKeysListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsSshKeysListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsSshKeysListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-keys by name
func (r ApiCatalogDeploymentsSshKeysListRequest) Search(search string) ApiCatalogDeploymentsSshKeysListRequest {
	r.search = &search
	return r
}

func (r ApiCatalogDeploymentsSshKeysListRequest) Execute() (*PaginatedDeploymentKeyList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsSshKeysListExecute(r)
}

/*
CatalogDeploymentsSshKeysList Method for CatalogDeploymentsSshKeysList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsSshKeysListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsSshKeysListRequest {
	return ApiCatalogDeploymentsSshKeysListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentKeyList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsSshKeysListExecute(r ApiCatalogDeploymentsSshKeysListRequest) (*PaginatedDeploymentKeyList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentKeyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsSshKeysList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/ssh-keys/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsStatsRetrieveRequest struct {
	ctx        context.Context
	ApiService *CatalogDeploymentsAPIService
}

func (r ApiCatalogDeploymentsStatsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogDeploymentsStatsRetrieveExecute(r)
}

/*
CatalogDeploymentsStatsRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCatalogDeploymentsStatsRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsStatsRetrieve(ctx context.Context) ApiCatalogDeploymentsStatsRetrieveRequest {
	return ApiCatalogDeploymentsStatsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsStatsRetrieveExecute(r ApiCatalogDeploymentsStatsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsStatsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsTasksCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	deploymentId   string
	deploymentTask *DeploymentTask
}

func (r ApiCatalogDeploymentsTasksCreateRequest) DeploymentTask(deploymentTask DeploymentTask) ApiCatalogDeploymentsTasksCreateRequest {
	r.deploymentTask = &deploymentTask
	return r
}

func (r ApiCatalogDeploymentsTasksCreateRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsTasksCreateExecute(r)
}

/*
CatalogDeploymentsTasksCreate ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsTasksCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksCreate(ctx context.Context, deploymentId string) ApiCatalogDeploymentsTasksCreateRequest {
	return ApiCatalogDeploymentsTasksCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksCreateExecute(r ApiCatalogDeploymentsTasksCreateRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsTasksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentTask == nil {
		return localVarReturnValue, nil, reportError("deploymentTask is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentTask
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsTasksListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	action       *string
	id           *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
	status       *string
}

// The action the task will perform  * &#x60;start_instances&#x60; - Start all instances in the deployment * &#x60;stop_instances&#x60; - Stop all instances in the deployment
func (r ApiCatalogDeploymentsTasksListRequest) Action(action string) ApiCatalogDeploymentsTasksListRequest {
	r.action = &action
	return r
}

func (r ApiCatalogDeploymentsTasksListRequest) Id(id string) ApiCatalogDeploymentsTasksListRequest {
	r.id = &id
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogDeploymentsTasksListRequest) Ordering(ordering string) ApiCatalogDeploymentsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogDeploymentsTasksListRequest) Page(page int32) ApiCatalogDeploymentsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogDeploymentsTasksListRequest) PageSize(pageSize int32) ApiCatalogDeploymentsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for deployment-tasks by action, id, status, status_text
func (r ApiCatalogDeploymentsTasksListRequest) Search(search string) ApiCatalogDeploymentsTasksListRequest {
	r.search = &search
	return r
}

// Current status of the task  * &#x60;completed&#x60; - completed * &#x60;failed&#x60; - failed * &#x60;pending&#x60; - pending * &#x60;processing&#x60; - processing * &#x60;retrying&#x60; - retrying
func (r ApiCatalogDeploymentsTasksListRequest) Status(status string) ApiCatalogDeploymentsTasksListRequest {
	r.status = &status
	return r
}

func (r ApiCatalogDeploymentsTasksListRequest) Execute() (*PaginatedDeploymentTaskList, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsTasksListExecute(r)
}

/*
CatalogDeploymentsTasksList ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@return ApiCatalogDeploymentsTasksListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksList(ctx context.Context, deploymentId string) ApiCatalogDeploymentsTasksListRequest {
	return ApiCatalogDeploymentsTasksListRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
//
//	@return PaginatedDeploymentTaskList
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksListExecute(r ApiCatalogDeploymentsTasksListRequest) (*PaginatedDeploymentTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeploymentTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsTasksRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	deploymentId string
	id           string
}

func (r ApiCatalogDeploymentsTasksRetrieveRequest) Execute() (*DeploymentTask, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsTasksRetrieveExecute(r)
}

/*
CatalogDeploymentsTasksRetrieve ðŸš§ [Beta Feature]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId
	@param id
	@return ApiCatalogDeploymentsTasksRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksRetrieve(ctx context.Context, deploymentId string, id string) ApiCatalogDeploymentsTasksRetrieveRequest {
	return ApiCatalogDeploymentsTasksRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return DeploymentTask
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsTasksRetrieveExecute(r ApiCatalogDeploymentsTasksRetrieveRequest) (*DeploymentTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{deployment_id}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogDeploymentsUpdateRequest struct {
	ctx              context.Context
	ApiService       *CatalogDeploymentsAPIService
	id               string
	deploymentUpdate *DeploymentUpdate
}

func (r ApiCatalogDeploymentsUpdateRequest) DeploymentUpdate(deploymentUpdate DeploymentUpdate) ApiCatalogDeploymentsUpdateRequest {
	r.deploymentUpdate = &deploymentUpdate
	return r
}

func (r ApiCatalogDeploymentsUpdateRequest) Execute() (*DeploymentUpdate, *http.Response, error) {
	return r.ApiService.CatalogDeploymentsUpdateExecute(r)
}

/*
CatalogDeploymentsUpdate Method for CatalogDeploymentsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this deployment.
	@return ApiCatalogDeploymentsUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsUpdate(ctx context.Context, id string) ApiCatalogDeploymentsUpdateRequest {
	return ApiCatalogDeploymentsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeploymentUpdate
func (a *CatalogDeploymentsAPIService) CatalogDeploymentsUpdateExecute(r ApiCatalogDeploymentsUpdateRequest) (*DeploymentUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogDeploymentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/deployments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesCreateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	experienceNote *ExperienceNote
}

func (r ApiCatalogExperiencesNotesCreateRequest) ExperienceNote(experienceNote ExperienceNote) ApiCatalogExperiencesNotesCreateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiCatalogExperiencesNotesCreateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesCreateExecute(r)
}

/*
CatalogExperiencesNotesCreate Method for CatalogExperiencesNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@return ApiCatalogExperiencesNotesCreateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesCreate(ctx context.Context, experienceId string) ApiCatalogExperiencesNotesCreateRequest {
	return ApiCatalogExperiencesNotesCreateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesCreateExecute(r ApiCatalogExperiencesNotesCreateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesDestroyRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	id           string
}

func (r ApiCatalogExperiencesNotesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesDestroyExecute(r)
}

/*
CatalogExperiencesNotesDestroy Method for CatalogExperiencesNotesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiCatalogExperiencesNotesDestroyRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesDestroy(ctx context.Context, experienceId string, id string) ApiCatalogExperiencesNotesDestroyRequest {
	return ApiCatalogExperiencesNotesDestroyRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesDestroyExecute(r ApiCatalogExperiencesNotesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesListRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	createdBy    *int32
	experience   *string
	fields       *string
	id           *string
	modifiedBy   *int32
	omit         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	search       *string
}

func (r ApiCatalogExperiencesNotesListRequest) CreatedBy(createdBy int32) ApiCatalogExperiencesNotesListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiCatalogExperiencesNotesListRequest) Experience(experience string) ApiCatalogExperiencesNotesListRequest {
	r.experience = &experience
	return r
}

// Include only the specified fields in the response
func (r ApiCatalogExperiencesNotesListRequest) Fields(fields string) ApiCatalogExperiencesNotesListRequest {
	r.fields = &fields
	return r
}

func (r ApiCatalogExperiencesNotesListRequest) Id(id string) ApiCatalogExperiencesNotesListRequest {
	r.id = &id
	return r
}

func (r ApiCatalogExperiencesNotesListRequest) ModifiedBy(modifiedBy int32) ApiCatalogExperiencesNotesListRequest {
	r.modifiedBy = &modifiedBy
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogExperiencesNotesListRequest) Omit(omit string) ApiCatalogExperiencesNotesListRequest {
	r.omit = &omit
	return r
}

// Which field to use when ordering the results.
func (r ApiCatalogExperiencesNotesListRequest) Ordering(ordering string) ApiCatalogExperiencesNotesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiCatalogExperiencesNotesListRequest) Page(page int32) ApiCatalogExperiencesNotesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiCatalogExperiencesNotesListRequest) PageSize(pageSize int32) ApiCatalogExperiencesNotesListRequest {
	r.pageSize = &pageSize
	return r
}

// Search for experience-notes by content
func (r ApiCatalogExperiencesNotesListRequest) Search(search string) ApiCatalogExperiencesNotesListRequest {
	r.search = &search
	return r
}

func (r ApiCatalogExperiencesNotesListRequest) Execute() (*PaginatedExperienceNoteList, *http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesListExecute(r)
}

/*
CatalogExperiencesNotesList Method for CatalogExperiencesNotesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@return ApiCatalogExperiencesNotesListRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesList(ctx context.Context, experienceId string) ApiCatalogExperiencesNotesListRequest {
	return ApiCatalogExperiencesNotesListRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
	}
}

// Execute executes the request
//
//	@return PaginatedExperienceNoteList
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesListExecute(r ApiCatalogExperiencesNotesListRequest) (*PaginatedExperienceNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedExperienceNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.modifiedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by", r.modifiedBy, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	id             string
	experienceNote *ExperienceNote
}

func (r ApiCatalogExperiencesNotesPartialUpdateRequest) ExperienceNote(experienceNote ExperienceNote) ApiCatalogExperiencesNotesPartialUpdateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiCatalogExperiencesNotesPartialUpdateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesPartialUpdateExecute(r)
}

/*
CatalogExperiencesNotesPartialUpdate Method for CatalogExperiencesNotesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiCatalogExperiencesNotesPartialUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesPartialUpdate(ctx context.Context, experienceId string, id string) ApiCatalogExperiencesNotesPartialUpdateRequest {
	return ApiCatalogExperiencesNotesPartialUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesPartialUpdateExecute(r ApiCatalogExperiencesNotesPartialUpdateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesRetrieveRequest struct {
	ctx          context.Context
	ApiService   *CatalogDeploymentsAPIService
	experienceId string
	id           string
	fields       *string
	omit         *string
}

// Include only the specified fields in the response
func (r ApiCatalogExperiencesNotesRetrieveRequest) Fields(fields string) ApiCatalogExperiencesNotesRetrieveRequest {
	r.fields = &fields
	return r
}

// Exclude the specified fields in the response
func (r ApiCatalogExperiencesNotesRetrieveRequest) Omit(omit string) ApiCatalogExperiencesNotesRetrieveRequest {
	r.omit = &omit
	return r
}

func (r ApiCatalogExperiencesNotesRetrieveRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesRetrieveExecute(r)
}

/*
CatalogExperiencesNotesRetrieve Method for CatalogExperiencesNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiCatalogExperiencesNotesRetrieveRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesRetrieve(ctx context.Context, experienceId string, id string) ApiCatalogExperiencesNotesRetrieveRequest {
	return ApiCatalogExperiencesNotesRetrieveRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesRetrieveExecute(r ApiCatalogExperiencesNotesRetrieveRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.omit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omit", r.omit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCatalogExperiencesNotesUpdateRequest struct {
	ctx            context.Context
	ApiService     *CatalogDeploymentsAPIService
	experienceId   string
	id             string
	experienceNote *ExperienceNote
}

func (r ApiCatalogExperiencesNotesUpdateRequest) ExperienceNote(experienceNote ExperienceNote) ApiCatalogExperiencesNotesUpdateRequest {
	r.experienceNote = &experienceNote
	return r
}

func (r ApiCatalogExperiencesNotesUpdateRequest) Execute() (*ExperienceNote, *http.Response, error) {
	return r.ApiService.CatalogExperiencesNotesUpdateExecute(r)
}

/*
CatalogExperiencesNotesUpdate Method for CatalogExperiencesNotesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param experienceId
	@param id
	@return ApiCatalogExperiencesNotesUpdateRequest
*/
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesUpdate(ctx context.Context, experienceId string, id string) ApiCatalogExperiencesNotesUpdateRequest {
	return ApiCatalogExperiencesNotesUpdateRequest{
		ApiService:   a,
		ctx:          ctx,
		experienceId: experienceId,
		id:           id,
	}
}

// Execute executes the request
//
//	@return ExperienceNote
func (a *CatalogDeploymentsAPIService) CatalogExperiencesNotesUpdateExecute(r ApiCatalogExperiencesNotesUpdateRequest) (*ExperienceNote, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExperienceNote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogDeploymentsAPIService.CatalogExperiencesNotesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalog/experiences/{experience_id}/notes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"experience_id"+"}", url.PathEscape(parameterValueToString(r.experienceId, "experienceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.experienceNote == nil {
		return localVarReturnValue, nil, reportError("experienceNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.experienceNote
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
